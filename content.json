{"pages":[{"title":"关于","text":"这里是得意喵喵的小窝~得意喵~生日：2000-04-17&amp;2000-11-22就读院校：USTC&amp;XJTU兴趣：钢琴 长笛 睡觉。。。。。。","link":"/about/index.html"},{"title":"友链","text":"None None","link":"/links/index.html"}],"posts":[{"title":"Busoni改编的Chaconne","text":"Chaconne in d minor BWV1004 小提琴solo，Bach原作，被Busoni改编成钢琴曲，带有一定炫技成分，十分绚丽。四年前在一次音乐会上听一位同学演奏这首曲目，当时留下了深刻的印象，十分想练习。奈何能力不够，一直拖到了现在，目前第一部分高潮结束前已经练完了。但是感觉自己对这首曲目的结构一无所知，照着谱干练，典型的傻子弹琴，但又不是专业人士，无法对音乐结构有确切把握，难啊！目前喜欢的版本有Helene Grimaud演奏的版本，这个版本流传最广，处理十分细腻，感觉都是非常经典的处理方式。Shura Cherkassky 演奏的版本感觉有不一样的味道，特别是第一段高潮的部分可以明显的听出两个声部，中间转调后的声部也非常清晰。虽然有错音，但是非常好听。感觉应该和Shura本人的练琴方式有关，Shura用一种非常慢的方式练琴，处理起来必然比其他人更加细腻。第一次看到他演奏的视频，弹的是一首吕利的巴洛克小品。当时就被视频中慈眉善目的老头的琴声吸引了，看他的面相也大致能推测出他的音乐风格。还有两个喜欢的版本是Olivier Latry和Christoph Reinhold的管风琴版，感觉管风琴的庄重感和多声部的表现远胜于钢琴。喜欢的原因有两个：1 能够更好的表现出多个声部，Helene Grimaud的版本听着是很爽，但是爽完就完了，没有那种回味无穷的感觉。管风琴版本几乎每一个变奏主题，可以听出另一个声部对第一个主题的重复，似隐似现，回味无穷。2 管风琴有些地方的处理是和钢琴十分不同的。比如第65小节，钢琴处理会表现得很活跃，速度比较快（参见Helene的版本），但是管风琴就明显有减慢的处理，往后拖一些，感觉更加庄重了。chaconne好听难练，真应了那句俗语：樱桃好吃树难栽。无论如何，慢慢打磨吧，现在弹不好，慢慢练练，到了三十几岁总能弹得差不多。实在不行，还有退休后的时光呢，哈哈哈。 附上Busoni改编的chaconne链接。Busoni-chaconne","link":"/2022/04/10/Busoni%E6%94%B9%E7%BC%96%E7%9A%84Chaconne/"},{"title":"Daboux矢量的变换关系","text":"Daboux矢量与旋转张量之间的关系若矢量，满足，则与满足以下关系式： 分量形式： 张量形式：","link":"/2022/10/06/Daboux%E7%9F%A2%E9%87%8F%E7%9A%84%E5%8F%98%E6%8D%A2%E5%85%B3%E7%B3%BB/"},{"title":"VASP计算Bader电荷方法","text":"什么是Bader电荷？一个分子中，电荷在分子所占据的空间中并不是均匀分布的。在每两个原子之间，电荷密度分布不均匀同时越是靠近原子，电荷密度会显著提高。因此，两个较大的数值之间存在一个极小值，这个极小值就是把原子分开的界限。一个原子周围的极小值点会形成一个封闭的区域这个区域可以用来划分分子中的原子，这个区域中的电荷综合就是Bader电荷。（VASP中使用赝势，因此所计算的电荷总和是当前化学环境中的所有“价层”电子总和） Bader电荷计算​ Bader是用于计算Bader的软件，读入文件有两种： 1 VASP CHGCAR文件； 2 Gaussian CUBE文件 软件会自己识别文件格式，不需要手动指定。 用法 1Bader filename 选项如下表： 选项 含义 -c bader \\ voronoi 开启bader计算/Voronoi多面体计算 -n bader \\ voronoi 关闭bader计算/Voronoi多面体计算 -b neargrid \\ ongrid \\ weight 三种Bader网格划分算法 -r refine_edge_method 默认-1一般使用-1（新算法 高效；旧算法为-2） -ref reference_charge 参考电荷（推荐-ref file(AECCAR0+AECCAR2)） -vac off \\ auto \\ vacuum_density 默认指定低密度点给真空层（1e-3/A^3判断标准） -p all_atom \\ all_bader 输出选项 -p sel_atom \\ sel_bader 输出选项（选择） -p sum_atom \\ sum_bader 输出选项（求和） -p atom_index \\ bader_index 输出选项（指标） -i cube \\ chgcar 默认会自己判断，一般不设置！ -cp 选择关键点 -h 帮助 -v 冗余输出 输出文件： 文件名 内容 ACF.dat 坐标 电荷 到表面（内层）的最小距离 体积 BCF.dat 坐标 电荷 最近的原子 离最近原子的距离 AVF.dat 体积 粗莽做法： 不考虑内层电子，采用赝势的内层电子数（一般来说内层电子变化不大） 1bader CHGCAR 官方建议做法： 考虑内层电子，考虑全电子状态 123LAECHG =.TRUE.LCHARG = .TRUE.NSW = 0 12chgsum.pl AECCAR0 AECCAR2bader CHGCAR -ref CHGCAR_sum","link":"/2022/07/30/VASP%E8%AE%A1%E7%AE%97Bader%E7%94%B5%E8%8D%B7%E6%96%B9%E6%B3%95/"},{"title":"n维球以及n维正n+1面体的体积与表面积","text":"一个递归方法的应用: 求 递归表达式为: 12Simplify@RSolve[{f[n] == x^n*Exp[x] - n*f[n - 1], f[1] == (x - 1) Exp[x]}, f[n], n] // TraditionalForm 对球和正n+1面体:1 球: 换元后 123456789101112131415161718Clear[\"`*\"];g[n] = Integrate[Cos[x]^n, {x, -Pi/2, Pi/2}, Assumptions -&gt; n &gt; 0];RSolve[{a[n] == a[n - 1]*g[n], a[1] == 2}, a[n], n] // TraditionalForm ;f[n_] := (2 \\[Pi]^(n/2))/(n Gamma[n/2]);ListPlot[Table[(2 \\[Pi]^(n/2))/(n Gamma[n/2]), {n, 0, 20}]];ListPlot[Table[f[x], {x, 0, 20, 0.02}], PlotTheme -&gt; \"Detailed\"]Max[Table[f[x], {x, 5, 6, 0.0001}]];ListPlot[Table[(f[x + 0.0001] - f[x])/0.0001, {x, 5, 6, 0.0001}]];FindRoot[D[f[x], x], {x, 1, 10}];L[n_] = Simplify[n*f[n]];ListPlot[Table[L[n], {n, 0, 20, 0.02}], PlotTheme -&gt; \"Detailed\"];FindRoot[D[L[x], x], {x, 1, 10}];Integrate[f[2*x], {x, 0, Infinity}, Assumptions -&gt; x \\[Element] Integer]Sum[f[x], {x, 0, Infinity}]Sum[L[2*n + 1], {n, 0, Infinity}] 体积系数: 表面积系数: 绘图: n维球在n=5.257是体积系数有最大值,5.27777 在n=7.257时表面积系数有最大值,33.1612 为啥呢? 我也不知道了. 体积系数和表面积系数是收敛的: 求和有: 体积系数和： 为误差函数。 偶数项和: 奇数项和： 表面积系数和： 偶数项和： 奇数项和： 2 正n+1面体:高系数递推公式: 1H_n=\\sqrt{1-(\\frac{n-1}{n}H_{n-1})^2} 体积系数的递推公式： 12a[n_] := -((I^n Sqrt[(-1)^n (n + n^2)])/(Sqrt[2] n));RSolve[{b[n] == 1/n*a[n]*b[n - 1], b[2] == Sqrt[3]/4}, b[n], n]; 高系数： 体积系数: 表面积系数: 为什么会有复数? 不知道了.可以画幅频曲线，相频曲线？？ 注：以前看过网上有一个日本高考题，证明 ，使用的线性化方法。 可以出一个题：证明偶数维球体积系数之和大于21.","link":"/2022/03/18/n%E7%BB%B4%E7%90%83%E4%BB%A5%E5%8F%8An%E7%BB%B4%E6%AD%A3n-1%E9%9D%A2%E4%BD%93%E7%9A%84%E4%BD%93%E7%A7%AF%E4%B8%8E%E8%A1%A8%E9%9D%A2%E7%A7%AF/"},{"title":"如何以张量的观点看待曲线论？","text":"传统微分几何对曲线论的介绍中以Frenet标架引入（具有几何直观），但是如何以张量的观点看待曲线论呢？ 定义Frame指一组向量，满足： 性质上式可以推出如下性质： 1 2 之间的关系对于Frenet:对于Bishop:若：有：结合上述表达式：注意这里 不求和。可以得到如下结论：可以发现Daboux矢量和旋转张量完全是由和诱导出来的。因此说Frenet方程决定了曲线的内禀结构。 3 Bishop Frenet Material frame 之间的关系考虑，即参考标架之间的转动。得到重要表达式：考虑转动以及三种形式的标架：三种frame：由上式张量方程可以得到：Bishop沿轴转动，得到Frenet标架，满足：Bishop沿轴转动，得到Material标架，满足：Frenet沿轴转动，得到Material标架，满足：","link":"/2022/11/19/%E5%A6%82%E4%BD%95%E4%BB%A5%E5%BC%A0%E9%87%8F%E7%9A%84%E8%A7%82%E7%82%B9%E7%9C%8B%E5%BE%85%E6%9B%B2%E7%BA%BF%E8%AE%BA%EF%BC%9F/"},{"title":"失眠了......","text":"失眠了，发发牢骚……每次看到一些社会上的新闻，我都感到心头一颤，不知道是痛心还是同情还是害怕这种事情有一天会降临到我的头上。今年以来发生了太多事情，我觉得我慢慢在成长，慢慢看到了世界的本来面目。我不想要任何东西，我只想要实现自己人生价值同时让自己在亲人、长辈的人生中起到积极作用，为他们进行付出就像他们曾经为了我付出一样。仔细想想今年发生的社会上的对我心理有影响的事情有如下几件： 某人因矛盾纠纷，而做出错误行为 某人因学业压力而做出严重错误行为 唐山打人事件 某同学因与房东纠纷而做出严重错误行为 河南乱赋红码行为 网传ustc学生骂人事件 宠物区up主被网络喷子攻击 “小镇做题家” **艺考事件 还有一些事并非发生在今年，但是同样对我的心理产生了很大影响。每次看到类似的新闻我心里都会想会不会有一天这种事情降临到我或者家人头上，怎么才能躲避开这种事情呢？每次看到这种负面消息，真的内心对这个society很失望，公平正义可能也是存在的，但是迟来的公平与正义是不是还不如将事情处理到不需要依赖公平正义解决的地步比较好？处理到不需要依赖公平正义的方式我能想到的可能有两种：1 资本家 拥有金钱与权利 金钱与权利绝大部分情况下可以解决大部分问题。2 普通人 提高自身素养，少说话，多做事，平和心态不要动怒，不和性格有较大缺陷的人深交，一旦发现身边的人不对劲刘赶紧避开，这样也难免避免被某些恶狗咬一口，但是同样可以处理绝大部分问题。作为普通人我只能选择第二种，每当这种事情发生都必须提醒自己需要清醒地生活不然类似的事情时刻有可能降临。想要入世就必须面对各种各样的问题，或许有的问题从根本上就是无法解决。因为规则是本着公平的态度为每个人制定的，但是人与人之间本来就不公平，社会地位，经济实力，智商高低，品德好坏，这种情况下，规则被破坏是必然的。每次出现这些问题我都能想起朱光潜在书中教导年轻人应该这么做：以出世的态度做入世的事业。简而言之，思想上出世，行为上入世。（这是在他的学生commit suicide之后写的）老先生原文的意思应该是不要在巨大困难面前受挫，不要被一些世俗的诱惑迷惑。而要一心去做自己喜欢的事。每次想到这些感觉能够释怀一些，但是这样真的很难。几乎没有人会单纯为了喜欢去做事情，而且如何在做事的过程中（入世），碰到挫折而突然转变为出世的心态。既要积极向上又不能患得患失，这可真是大难题！老先生在书中也没有讨论这个问题，可能是需要通过提高自身思想素质来解决吧。这种人固然少（转向古代服饰研究的沈从文等），但是存在，做不到只能说明自身思想素质还达不到。从这个角度看，让自己生活在“象牙塔”里也许并不是一件坏事。人生本来就不长，与奇怪的事情纠缠不如看一分钟可爱宠物。真的十分心疼那位高铁站的学长。孔子说：中人以下，不可以语上。社会上所谓的“中人以下”并不在少数，但是却不得不接触他们，譬如那位大白，还有那些在“某音”，“微博”上疯狂输出情绪的网民。互联网毁掉一个人太容易了，所谓的“官方”也只是称谓，正如桌子叫做桌子椅子叫做椅子一样。（不然也不会说出小镇做题家之类的话吧）所有的行为令我感到十分不能理解，不能理解就不要理解，妄图理解也是白费精力。这也正说明必须择道而行才能避开这些奇怪的生物。不能用这么消极的词汇“失望”，这也许是成年后对这个society更清醒的认识罢了。曾经和两位朋友交流过这些想法，他们说这些已经司空见惯，感到自己已经见怪不怪了。也许是我太过敏感了。随着年龄增长我越来越能感受到小时候对想要了解更多的世界，想象着世界的美好，但是后来了解到的世界并非那么美好，或许完全相反？一尊石碑，介时能不入土？功名利禄，试问人心何处？","link":"/2022/07/18/%E5%A4%B1%E7%9C%A0%E4%BA%86/"},{"title":"宠物名片","text":"用mathematica可以制作一些宠物名片12345678Clear[\"`*\"];p={{Item[烟灰.png,Alignment-&gt;Center],SpanFromLeft},{\"stuID\",\"2196001122\"},{\"姓名\",\"烟灰\"},{\"精神面貌\",\"宠物\"},{\"主人\",\"～～\"},{\"颜色\",\"白色\"},{\"业余爱好\",\"吃饭，睡觉\"},{Item[Style[\"学习成绩\",Bold],Alignment-&gt;Center],SpanFromLeft},{\"语文\",\"59\"},{\"数学\",\"58\"},{\"英语\",\"66\"},{Item[Style[\"光荣事迹\",Bold],Alignment-&gt;Center],\"床上拉屎\"},{SpanFromAbove,\"叼樱桃\"},{SpanFromAbove,\"玩卫生纸\"},{SpanFromAbove,\"抓沙发\"}};p[[2;;7,1]]=Style[#,Bold]&amp;/@p[[2;;7,1]];p[[9;;11,1]]=Style[#,Bold]&amp;/@p[[9;;11,1]];Grid[p,Alignment-&gt;Left,Frame-&gt;All]123456789Clear[\"`*\"];q={{\"光荣事迹\",SpanFromLeft,SpanFromLeft,SpanFromLeft},{\"偷吃烧鸡\",\"偷吃金鱼\",\"偷吃兔子\",\"偷吃贡品\"}}//Transpose;p={{Item[黑猫.png,Alignment-&gt;Center],SpanFromLeft},{\"stuID\",\"2186000417\"},{\"姓名\",\"黑猫老弟\"},{\"精神面貌\",\"宠物\"},{\"主人\",\"－－\"},{\"颜色\",\"黑色\"},{\"业余爱好\",\"干坏事\"},{Item[Style[\"学习成绩\",Bold],Alignment-&gt;Center],SpanFromLeft},{\"语文\",\"36\"},{\"数学\",\"57\"},{\"英语\",\"49\"},{Item[Style[\"光荣事迹\",Bold],Alignment-&gt;Center],\"偷吃烧鸡\"},{SpanFromAbove,\"偷吃金鱼\"},{SpanFromAbove,\"偷吃兔子\"},{SpanFromAbove,\"偷吃贡品\"}};p[[2;;7,1]]=Style[#,Bold]&amp;/@p[[2;;7,1]];p[[9;;11,1]]=Style[#,Bold]&amp;/@p[[9;;11,1]];Grid[p,Alignment-&gt;Left,Frame-&gt;All]","link":"/2022/07/18/%E5%AE%A0%E7%89%A9%E5%90%8D%E7%89%87/"},{"title":"写过的诗","text":"以前写过的一些诗，作为记录。 赏花微粉轻藏翠叶中去年还是满头空拟把今日作昨日明朝青墨不掩红 成吉思汗横扫塞北朔漠倏尔弓起雕落会将长枪东指平原万里逐鹰 对子歌雷对电 霓对虹 落日对长弓狂沙对乱石 明月对青冢千山外 万丈前 嘶噎对寒风还忆旧时苑 车水马如龙四十年来家国恨 三千里地山河残旧游在否林花谢了春红故国繁雄恰似一场空梦 无题蝉鸣清心戾荷光映流年石阶浅浅绿萝填且伴流水渐渐今日心中事后主当年情试问游鱼真知否幽苔石上生 忆江南江南好最是雨绵绵堤上细柳随风走岸边繁花映古楼何日复重游 江南美最美是苏州画舫楼上观荷叶网师园里赏琴筝人间无此声 江南忆最忆是旧游欢笑声中谈趣事环形岛上论沙鸥此生无此行 都江堰千丝万缕于心中青山一睹万事空峥嵘岁月仍在否万古长流且向东 渔家傲 秋思交大秋来风景异纷纷扬扬无留意枫叶满地金万里何日起星星点点随风去 倘若回首星夜里辉煌且随时光去黯然废物铺满地因何异谁道人生无对立 黑猫双瞳夜里如光且试爪下锋芒何畏山高地险信步还似平常 南乡子我是一只喵 飞檐走壁踩高跷 纵深飞跃何惧险黑猫惊叫声里水上漂烧鸡嘴上叼 隔壁金鱼爪中捞 小小兔崽口中嚼饿了(liao)烟灰喜欢喵喵喵 数学是什么小学时数学是卷子上的一百分我在前头同桌在后头初中时数学是几条有趣的图线我在外头答案在里头高中时数学是一支二部创意曲图像在上头公式在下头而今啊数学是一堆堆神奇的符号我在这头世界在那头","link":"/2022/01/30/%E6%88%91%E5%86%99%E8%BF%87%E7%9A%84%E8%AF%97/"},{"title":"弹性线问题与数值求解","text":"一根绳子，当受到一定的力，弯矩，扭矩时他的形状是什么样的？ 预备工作 建立Euler弹性线方程 分析求解 数值求解 黎曼空间中的弹性线 附录Cpp代码 预备工作分部积分法的妙用浅谈分部积分公式中通过迭代得到了：通过这个公式也得到了高阶Lagrange方程，这里简单的总结一下，方便后边使用：含有高阶导数的Lagrange方程为：对应守恒量： 几个椭圆函数一些符号变换而已 建立Euler弹性线方程不考虑弹性线的伸长时，弹性线的能量可以写为：这个不考虑伸长有一定的物理意义，并不意味着弹性线的弹性系数很大。比如说一根松弛状态弯曲的橡皮筋，虽然橡皮筋很容易伸缩变形，但是由于绳子并没有绷紧，因此也可以看成不考虑弯曲能的情况。在不考虑转动时，能量仅仅由曲率进行贡献。曲率与矢径的关系为：。利用Lagrange乘数法，得到能量泛函：这时应用前面的二阶导数的Lagrange方程，得到：守恒量为：上面得到的只是矢径需要满足的关系，要想把矢径和曲线的内禀量（什么是内禀量？内禀量是系统本身的性质，不随坐标系选取而改变，这里指的是曲率和挠率。）联系起来，需要把矢径投影到Frenet标架（不一定是Frenet标架，只要是曲线的随体标架都可以）中，并利用Frenet关系进行化简。（Add：如何理解内禀坐标？ 首先，对于一个空间曲线来说，选取不同位置为基点进行描述，矢径参数方程肯定是不同的，但是这个量与选取基点的方式无关。这也说明了为什么描述曲线自身性质的Frenet标架中不会含有，而含有的各阶导数。）满足关系式：投影后得到：（略去大量计算）要满足必须让三个分量为零：上式积分得到：后续只需要通过边界条件求解方程，然后把参数空间转换到欧氏空间中。 分析求解？？？？？？？？？？？？？ 数值求解弹性线问题中，为了方便起见，总是以内禀参数进行求解的。但是要想进行可视化，必须进行坐标的变换，简而言之就是从内禀参数空间变换到欧式空间。这个变换过程就是求解Frenet方程。数值求解的关键： 求解Frenet方程，把参数空间转化为欧氏空间。首先会想到二维情况如下图：猛一看这不是很简单嘛。啪！很快啊！于是通过几何关系很快就写出了参数空间与欧氏空间的变换关系。离散化：但是，如果考虑三维空间的情况这个几何关系是什么呢？也就是说，当从曲线上的一点向前前进了的距离，这个前进的过程中既有弯曲又有扭转，到达的位置怎么表达呢？要想和二维情况一样通过几何直觉来得到这个关系就很难了。于是，可以发现，上面的通过所谓的“几何直觉”得到转换关系的过程只不过是参数化的过程，借助中间参数进行转换。三维可不可以照猫画虎来一遍？于是想到，同样把弧长进行参数化如下：与内禀参数的关系怎么写？通过Frenet方程求解得到：到这一步，只要求解出和的关系就能把参数空间转化为欧氏空间。但是可以发现上面是一个复杂的非线性方程，离散起来需要花费很大功夫，因此这个方法行不通。绕了一个大弯，发现绕进了胡同里。既然参数空间的转化与Frenet方程有关，为何不直接求解Frenet方程？那么如何把Frenet方程转化到欧氏空间呢？通过这个关系式。至此已经有了求解思路，感觉这个思考过程很有意思。也许前面的弯路并没有白走，二维情况下的几何直觉引导我们想到三维情况。而三维情况下几何直觉不管用了，又得回去归纳前面通过“几何直觉”求解二维问题的流程。好不容易归纳好了，却发现同样的方法三维问题根本没法解。而这个时候发现了三维求解过程中与二维情况的不同：利用了Frenet方程。然后想到可能与Frenet方程有关，最终去求解Frenet方程，得到了参数空间向欧氏空间转换的一般方法。 离散Frenet方程以及得到： 至此，Euler弹性线（仅考虑弯曲能）的求解思路总结如下： 求解弹性线方程 得到内禀参数的演化规律 通过Frenet方程求解标架的演化规律 通过把参数空间映射到欧氏空间 PS: 以上是一个关于曲率的二阶方程，可以通过给定初始曲率以及曲率导数进行迭代（初值问题），也可以通过给定两个端点的导数利用打靶法进行求解（边值问题）。此外，Frenet方程的求解用Euler法会产生很大误差，连求解基本的圆误差都会很大，用预报矫正算法就会好很多。 上面已经给出了求解的方法，下面是几个求解结果的可视化(按照曲率着色) s 2 1 2 1 50 1.5 1 0.7 0.8 50 0.7 1 2 0.75 50 黎曼空间中的弹性线？？？？？？？？？？？？？ Cpp代码主函数(main.cpp)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#############Elastica类(EulerElasticaRod.h)##############include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;math.h&gt;using namespace std;struct Para{ static const int N=2000; double kappa[N]{},tau[N]{},coord[3][N];};class DER{public: // Para ks2coord(); DER(Para &amp;p1,double s1,double* kppa01,double k01,double dk01,double tau0,double ks,double lambda1);//构造函数 //不需要析构函数！！ Para SolveER(); double erfen(); double f(); double f1();private: Para p;double s;double* kppa0;double k0;double dk0;double tau0;double ks;double lambda; };DER::DER(Para &amp;p1,double s1,double* kppa01,double k01,double dk01,double tau01,double ks0,double lambda1){ p=p1;s=s1;kppa0=kppa01;k0=k01;dk0=dk01;ks=ks0;lambda=lambda1;tau0=tau01;}//就是不需要析构函数！！！//定义public函数Para DER::SolveER(){ int NN=p.N; double ds=s/NN; double c=k0*k0*tau0; p.kappa[0]=k0;p.kappa[1]=ds*dk0+k0;p.tau[0]=tau0; for (int i =1;i&lt;NN-1;i++) { p.kappa[i+1]=2*p.kappa[i]-p.kappa[i-1]+pow(ds,2)*(-0.5*pow(p.kappa[i],3)+0.5*lambda*p.kappa[i]+pow(c,2)/pow(p.kappa[i],3)); p.tau[i+1]=c/pow(p.kappa[i+1],2); } return p; } double DER::erfen(){ cout&lt;&lt;\"ks\"&lt;&lt;\" \"&lt;&lt;\"err\"&lt;&lt;endl; double ff0=this-&gt;f();double ff1=this-&gt;f1(); double eps=1e-6; while(true){ dk0=dk0-(ff0-ks)/ff1; ff0=DER(p,s,kppa0,k0,dk0,tau0,ks,lambda).f(); ff1=DER(p,s,kppa0,k0,dk0,tau0,ks,lambda).f1(); cout&lt;&lt;ff0&lt;&lt;\" \"&lt;&lt;abs(ff0-ks)&lt;&lt;endl; if (abs(ff0-ks)&lt;eps) break; } return dk0; }double DER::f(){ Para re=SolveER(); return re.kappa[re.N-1];}double DER::f1(){ double ddk=0.001; return (DER(p,s,kppa0,k0,dk0+ddk,tau0,ks,lambda).f()-DER(p,s,kppa0,k0,dk0,tau0,ks,lambda).f())/ddk;}#############主函数##############include \"EulerElasticaRod.h\"Para ks2coord(Para &amp;p, double s) { double Frenet[3][p.N][3] {}, ds = s / p.N; Frenet[0][0][0] = 1; Frenet[0][0][1] = 0; Frenet[0][0][2] = 0; Frenet[1][0][0] = 0; Frenet[1][0][1] = 1; Frenet[1][0][2] = 0; Frenet[2][0][0] = 0; Frenet[2][0][1] = 0; Frenet[2][0][2] = 1; for (int j = 0; j &lt; 3; j++) { p.coord[j][0] = 0; for (int i = 1; i &lt; p.N; i++) { Frenet[0][i][j] = Frenet[0][i - 1][j] + p.kappa[i - 1] * ds * Frenet[1][i - 1][j]; Frenet[2][i][j] = Frenet[2][i - 1][j] - p.tau[i - 1] * ds * Frenet[1][i - 1][j]; Frenet[1][i][j] = Frenet[1][i - 1][j] - p.kappa[i - 1] * ds * Frenet[0][i - 1][j] + p.tau[i - 1] * ds * Frenet[2][i - 1][j]; //预报校正算法 PS:简单的Euler法会导致比较大的误差，不信试试看！ Frenet[0][i][j] = Frenet[0][i - 1][j] + p.kappa[i - 1] * ds * (Frenet[1][i - 1][j] + Frenet[1][i][j]) / 2; Frenet[2][i][j] = Frenet[2][i - 1][j] - p.tau[i - 1] * ds * (Frenet[1][i - 1][j] + Frenet[1][i][j]) / 2; Frenet[1][i][j] = Frenet[1][i - 1][j] - p.kappa[i - 1] * ds * (Frenet[0][i - 1][j] + Frenet[0][i][j]) / 2 + p.tau[i - 1] * ds * (Frenet[2][i - 1][j] + Frenet[2][i][j]) / 2; p.coord[j][i] = p.coord[j][i - 1] + Frenet[0][i - 1][j] * ds; } } return p;}int main() { Para p; double s = 50, kappa[p.N] {}, k0 = 0.9, dk0 = 0.9, tau0 = 1, lambda = 0.75, ks = 2; double ppp = DER(p, s, kappa, k0, dk0, tau0, ks, lambda).erfen(); Para q = DER(p, s, kappa, k0, ppp, tau0, ks, lambda).SolveER(); // dk0=DER(p,s,kappa,k0,dk0,tau0,ks,lambda).erfen(); Para ret = ks2coord(q, s); cout &lt;&lt; ret.kappa[q.N - 1] &lt;&lt; endl; ofstream out(\"out.data\"); for (int i = 0; i &lt; p.N; i++) { out &lt;&lt; ret.coord[0][i] &lt;&lt; \" \" &lt;&lt; ret.coord[1][i] &lt;&lt; \" \" &lt;&lt; ret.coord[2][i]&lt;&lt;\" \"&lt;&lt;ret.kappa[i]&lt;&lt; endl; } out.close(); return 0;}","link":"/2022/11/02/%E5%BC%B9%E6%80%A7%E7%BA%BF%E9%97%AE%E9%A2%98%E4%B8%8E%E6%95%B0%E5%80%BC%E6%B1%82%E8%A7%A3/"},{"title":"弹性悬链线问题","text":"弹性悬链线考虑弹性能的悬链线可以从刚性悬链线通过扰动的方式得到： 1 非弹性解的形式考虑泛函： 带入Lagrange方程得到： 解得： 2 考虑弹性能先考虑绳子不伸长时的情况，如上所示。如果绳子具有弹性能，那么绳子上任意一点的坐标仅仅是绳子无伸长时的一个修正，这个修正是重力势能与弹性势能竞争的结果。 考虑绳子变化为,修正前后绳子的微元及坐标可以写成如下形式： 修正前：修正后： 能量变化可以写作如下表达式： 其中 可以看出Lagrange量具有如下形式： 其中 同时满足如下方程：变分后得到： 由(12)得到：上面为考虑弹性能时的一般性情况，当时，上式也应该满足。 得到：有： 带入(12)的②式并化简得到： 最终解得：","link":"/2022/10/09/%E5%BC%B9%E6%80%A7%E6%82%AC%E9%93%BE%E7%BA%BF%E9%97%AE%E9%A2%98/"},{"title":"收集的mathematica壁纸和图标","text":"分享一些wolfram壁纸，Logo以及复刻Logo的程序。 wolfram壁纸下面分享几张收藏的wolfram壁纸： wolfram小图标分享一些wolfram的小图标，可以用来制作wolfram手机主题。之前对利用wolfram图标制作手机主题热衷了一段时间，但是制作的手机主题需要通过魔秀桌面来完成，个人能力还不足以开发一个真正的wolfram主题。其次，网上找到的图标质量参差不齐，wolfram的图标太少，用来替代app图标不直观。因此，后来就没有再进行完善了。。。。。。＞﹏＜\\制作的wolfram手机主题太丑了，ヽ（≧□≦）ノ连我自己也看不下去。。。。。。把图标的背景去除用的是mathematica的RemoveBackground命令，注意需要导出png格式。 mathematica Logo复刻对于mma的logo，还可以进行复刻：123456789101112131415161718Clear[\"`*\"]; w[col_, r_] := Module[{p = Riffle[CirclePoints[{0.7*r, 0}, 10], CirclePoints[{r, (2*Pi)/20}, 10]]}, {col, FilledCurve@Line[p~Join~{p[[1]]}]}]; n[col_, r_, a_] := Module[{p = Riffle[CirclePoints[{0.2*a*r, Pi/10}, 5], CirclePoints[{0.8*r, (3 Pi)/10}, 5]]}, p = p~Join~{p[[1]], p[[2]]}; {col, FilledCurve@ Table[BezierCurve[p[[2 i ;; 2 i + 2]]], {i, 1, 5}]}] Manipulate[ Graphics[{w[Red, 1.05*r], n @@@ ({{White, Red, White, Red}, {1*r, 0.73*r, 0.5*r, 0.3*r}, {1*r, 1.4*r, 1.7*r, 1.8*r}} // Transpose)} // Flatten], {r, 0.8, 1.5}] 效果如下：内部图形的弯曲程度可以进行调节。","link":"/2022/01/30/%E6%94%B6%E9%9B%86%E7%9A%84mathematica%E5%A3%81%E7%BA%B8%E5%92%8C%E5%9B%BE%E6%A0%87/"},{"title":"氧化纤维素晶体建模问题","text":"今天终于把charmm力场氧化纤维晶体的建模问题搞定了，其实对于其他力场也大同小异。还是LAMMPS自带的建模功能牛逼。码住，这个得好好写写！ 概述纤维素晶体最常见的氧化形式是TEMPO晶体。具体形式是将纤维素晶体表面的羟甲基氧化为羧基，氧化度为0.1~0.5（另：硫化程度一般为0.1~0.2）。对于charmm力场，目前已有学者实现了纤维素晶体的建模（cellulose-toolkit）,但是由于模型建立的复杂性，目前对表面氧化的研究较少。（已有研究使用了oplsaa力场：Biomacromolecules 2020, 21, 3069−3080） 基本思路一般来说，高分子data文件中会把力场参数包括在内。\\两个原因：1 高分子体系中参数较多写在in文件中不方便。2 输出的不同类型原子之间的pair_coeff会根据混合规则（pair_modify）进行计算，因此不同混合规则下的pair_coeff是不同的。索性直接把单个类型原子的pair_coeff写在data文件中，而在in文件中声明混合规则。除此之外，也可以直接用include命令加入力场参数。这样就实现了力场参数与拓扑结构的分别读入。注意两点：1 虽然力场参数与拓扑结构是分别读入的，但是拓扑结构必须与对应的力场一致，例如不能读入charmm力场参数的同时使用oplsaa的拓扑结构。因为不同力场的原子类型不同。2 力场参数可以有冗余！这一点很重要，也就是说力场参数即使设置的多了有部分没有使用也不要紧。明白了上面两点，氧化纤维素晶体的建模本质上分为三个部分： 1 得到氧化纤维素晶体的Coeff参数文件 2 更改纤维晶体的拓扑结构 第一步可以通过在纤维素晶体的data文件中加入力场参数，然后用lammps自带的命令write_coeff得到想要的参数文件。（善于利用lammps自身的建模功能能解决很多问题。）加入力场参数可以通过python脚本实现，这里注意读入的data文件必须为lammps输出的标准data文件。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364# -*- codeing = utf-8 -*-# @Time :2022/9/9 23:34# @Author : 得意喵 ~# @File : addcoeff.py.py# @Software: PyCharmimport pandas as pdimport numpy as npimport re#define functionsdef findcoeff(data,coeff): for i in range(len(data)): if re.match(coeff,data[i]): return idef coeffformat(n,coeff0): return str(n)+' '+coeff0+'\\n'def getcoeffindex(coeff0): s=coeff0.split() return int(s[0])def addcoeffs(data,n,coeff,n0): for i in range(len(coeff)): data.insert(n+i,coeffformat(n0+i+1,coeff[i])) return data#open filesf=open('try.data','r')data=f.readlines()if data[10]=='\\n': data.insert(10,'0 impropers\\n') data.insert(11,'0 improper types\\n') data.insert(findcoeff(data,'Atom')-1,'\\n') data.insert(findcoeff(data,'Atom')-1,'Improper Coeffs\\n\\n')#types and coeffsnew_atomtypes=2new_bondtypes=2new_angletypes=5new_dihedraltypes=2new_impropertypes=1new_types=[2,2,5,2,1]newmasses=['12.011','15.999']newpaircoeffs=['0.07000000000000 3.56359487256136 0.07000000000000 3.56359487256136','0.12000000000000 3.02905564167715 0.12000000000000 3.02905564167715']newbondcoeffs=['525.000 1.2600','200.000 1.4800']newanglecoeffs=['40.00000 114.00000 50.00000 2.38800','100.00000 132.00000 70.00000 2.22500','50.00000 109.50000 0.00000 0.00000','45.00000 103.00000 0.00000 0.00000','52.00000 108.00000 0.00000 0.00000']newdihedralcoeffs=['0.0500 6 180 1.00','0.6400 2 180 1.00']newimpropercoeffs=['96.000 0.00']new_coeff=[newmasses,newpaircoeffs,newbondcoeffs,newanglecoeffs,newdihedralcoeffs,newimpropercoeffs]coeffindex=[];index=['Pair Coeffs','Bond Coeffs','Angle Coeffs','Dihedral Coeffs','Improper Coeffs','Atoms']#change typestypes=data[3:13:2]for i in range(5): s=types[i].split() s[0]=str(int(s[0])+new_types[i]) types[i]=' '.join(s)+'\\n'data[3:13:2]=types#add coeffsfor i in range(6): coeffindex.append(findcoeff(data,index[i])) if re.match('\\d.',data[coeffindex[i]-2]): data=addcoeffs(data,coeffindex[i]-1,new_coeff[i],getcoeffindex(data[coeffindex[i]-2])) else: data.insert(coeffindex[i]-1,coeffformat(1,new_coeff[i][0]))data1 = open(\"data_new.data\", \"w\")data1.write(\"\".join(data))data1.close()f.close()第二步可以通过lammps的建模功能实现。首先注意到，纤维素和氧化纤维素的模型如下图：可以看出氧化后相比于氧化前只少了羟甲基上的羟基原子。同时很有意思的一点是氧化后羧基碳上两个氧原子的类型是一样的，这与未氧化羟甲基碳上的两个相同类型的氢原子不谋而合。因此只要把羟基删去并重新更改氧化后的top信息就可以实现纤维素氧化，（不用增加其他的原子以及多余的top信息，除了增加一个离面二面角）。氧化前后的top信息总结如下：氧化前后力场参数对比不同的力场参数是通过charmmgui得到氧化前后多糖data文件对照后得出的。通过lammps自带命令改变原来data文件的top结构并赋予力场参数，可以实现羟甲基氧化为羧基后糖单元的charmm力场模型。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768units realatom_style fulldimension 3boundary f f f#Force fieldsbond_style harmonicangle_style charmmdihedral_style charmmfswimproper_style harmonic pair_style lj/charmmfsw/coul/charmmfsh 10.0 12.0pair_modify mix arithmeticread_data withoutcoeff.data extra/improper/per/atom 5special_bonds charmmneighbor 2.0 binneigh_modify every 100 delay 0 check yesinclude Oxide.coeff# define groupsgroup HO id 48 47group OO id 45 46group C id 44#add coeff# the coeff must be added to data file not the coeff file# it has been done with python code#1 delete_atoms delete_atoms group HO bond yes#2 set chargeset group OO charge -0.760set group C charge 0.520# # # #3 set pair set group OO type 16set group C type 15#4 set bond angle dihedral ########### Bond ###########group bondOC id 44 45 46set group bondOC bond 20group bondCC id 44 29set group bondCC bond 21########### Angle ###########group angle1 id 29 44 45set group angle1 angle 40group angle2 id 29 44 46set group angle2 angle 40group angle3 id 45 44 46set group angle3 angle 41group angle4 id 30 29 44set group angle4 angle 42group angle5 id 31 29 44set group angle5 angle 43group angle6 id 40 29 44set group angle6 angle 44########### Dihedral ###########group dihedral1 id 30 29 44 45set group dihedral1 dihedral 91group dihedral2 id 30 29 44 46set group dihedral2 dihedral 91group dihedral3 id 31 29 44 45set group dihedral3 dihedral 92group dihedral4 id 31 29 44 46set group dihedral4 dihedral 92group dihedral5 id 40 29 44 45set group dihedral5 dihedral 91group dihedral6 id 40 29 44 46set group dihedral6 dihedral 91#create and set impropercreate_bonds single/improper 1 44 29 46 45write_coeff Oxide.coeffwrite_data withoutcoeff.data nocoeff至此我们已经完成了羟甲基到羧基的氧化。后面基本上就大功告成了，要实现纤维素晶体的氧化只用在ovito中把羟甲基碳的原子序号找出来，把产生变化的原子序号写成选出的碳原子序号的表达式并用随机数选取进行氧化。（lammps中一个loop循环就可以搞定。） 放个图感受一下，哈哈哈。原理一样，氧化过程中需要注意： 1 variable中的随机数会随着调用次数进行变动，因此新建一个变量把它存储下来！！ 2 及时删除group！！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108units realatom_style fulldimension 3boundary f f f#Force fieldsbond_style harmonicangle_style charmmdihedral_style charmmfswimproper_style harmonic pair_style lj/charmmfsw/coul/charmmfsh 10.0 12.0pair_modify mix arithmeticread_data crystal_nocoeff.data extra/improper/per/atom 500special_bonds charmmneighbor 2.0 binneigh_modify every 100 delay 0 check yes# write_data crystal_new.datainclude crystal.coeffvariable NS loop 30label loopvariable seed equal ${NS}^2+2*${NS}+3932variable a290 equal round(random(0,1,${seed})*180)*42+34443variable a29 equal ${a290}print \" ${a29} \"# variable a29 equal 36921variable a44 equal ${a29}+14print \" ${a29} \"variable a45 equal ${a29}+15print \" ${a29} \"variable a46 equal ${a29}+16variable a47 equal ${a29}+17variable a48 equal ${a29}+18# define groupsgroup HO id ${a47} ${a48}group OO id ${a45} ${a46}group C id ${a44}#add coeff# the coeff must be added to data file not the coeff file# it has been done with python code#1 delete_atoms delete_atoms group HO bond yes#2 set chargeset group OO charge -0.760set group C charge 0.520# # # #3 set pair set group OO type 12set group C type 11#4 set bond angle dihedral ########### Bond ###########group bondOC id ${a44} ${a45} ${a46}set group bondOC bond 16group bondCC id ${a44} ${a29}set group bondCC bond 17########### Angle ###########group angle1 id ${a29} ${a44} ${a45}set group angle1 angle 33group angle2 id ${a29} ${a44} ${a46}set group angle2 angle 33group angle3 id ${a45} ${a44} ${a46}set group angle3 angle 34group angle4 id 30 ${a29} ${a44}set group angle4 angle 35group angle5 id 31 ${a29} ${a44}set group angle5 angle 36group angle6 id 40 ${a29} ${a44}set group angle6 angle 37########### Dihedral ###########group dihedral1 id 30 ${a29} ${a44} ${a45}set group dihedral1 dihedral 84group dihedral2 id 30 ${a29} ${a44} ${a46}set group dihedral2 dihedral 84group dihedral3 id 31 ${a29} ${a44} ${a45}set group dihedral3 dihedral 85group dihedral4 id 31 ${a29} ${a44} ${a46}set group dihedral4 dihedral 85group dihedral5 id 40 ${a29} ${a44} ${a45}set group dihedral5 dihedral 84group dihedral6 id 40 ${a29} ${a44} ${a46}set group dihedral6 dihedral 84#create and set impropercreate_bonds single/improper 1 ${a44} ${a29} ${a46} ${a45}group HO delete group OO deletegroup C deletegroup bondOC deletegroup bondCC deletegroup angle1 deletegroup angle2 deletegroup angle3 deletegroup angle4 deletegroup angle5 deletegroup angle6 deletegroup dihedral1 deletegroup dihedral2 deletegroup dihedral3 deletegroup dihedral4 deletegroup dihedral5 deletegroup dihedral6 delete# delete_atoms group HO bond yesnext NSjump SELF loopwrite_data Oxide.data nocoeff","link":"/2022/09/10/%E6%B0%A7%E5%8C%96%E7%BA%A4%E7%BB%B4%E7%B4%A0%E6%99%B6%E4%BD%93%E5%BB%BA%E6%A8%A1%E9%97%AE%E9%A2%98/"},{"title":"浅谈分部积分公式","text":"分部积分并非高数中表现的那么简单单纯，这个东西在变分过程中会经常用到。之前发现过一些关于分部积分有趣的性质，记录如下： 分部积分公式的几何意义即为：分部积分中的两部分在力学中表现为应变能与应变余能。 高阶公式以及在变分法中的应用一般地可表示为:Euler’s Elastica Rod控制方程求解中，泛函可以写成如下形式：求变分后得到此时上面的公式就派上用场了，直接带入得到： 上面那个一般性公式有没有更好看更对称的写法? 如何从给定泛函中直接看出变分后的结果? 分部积分公式的正负交错导致了含有高阶项拉格朗日方程的正负交错结果！(我也能从单变量泛函中直接看出来变分后的结果了！) 含高阶导数的Lagrange方程的一般形式：利用上面的一般性分部积分公式，可以得到含高阶导数的Lagrange方程的一般形式：得到高阶Lagrange方程为：若满足诺特定理，守恒量为：","link":"/2022/10/07/%E6%B5%85%E8%B0%88%E5%88%86%E9%83%A8%E7%A7%AF%E5%88%86%E5%85%AC%E5%BC%8F/"},{"title":"用mathematica去水印","text":"mathematica去除学习资料中的水印。如下图：比较简单，对于学习资料中的水印来说。 效果图：","link":"/2022/01/30/%E7%94%A8mathematica%E5%8E%BB%E6%B0%B4%E5%8D%B0/"},{"title":"用mathematica实现剪力弯矩图的解析求解以及示意图绘制","text":"介绍在材料力学课程中绘制剪力图，弯矩图以及挠度曲线 是求解梁变形问题的基础。在习题中，载荷往往得到了简化：恒定载荷 或者线分布载荷 。实际工程中，如果载荷分布可以利用查表法进行求解，容易解得梁的挠度等参数，但是如果载荷是任意分布的，这时候求解梁的变形问题就需要利用计算机来求解。一个基本的想法是，利用微元法，先把梁上的载荷按长度细分，然后拟合出一个载荷分布函数再求解。但是，拟合出来的函数往往不是那么的简单 ，人力计算几乎很难做到。 除此之外，对于梁的挠度曲线在工程上一般会使用三次函数来近似，并非一个解析的结果。利用mathematica强大的符号运算功能可以得到挠度曲线的解析形式 。 以前想过做一个app，后来发现ipad应用商店已经有了(((φ(◎ロ◎;)φ))套了个gui) 基本思想梁一般分为悬臂梁，简支梁，外伸梁三种样式。外伸梁和简支梁在求解形式上是相同的，只是支座位置不同，悬臂梁与二者不同。 具体步骤： 利用受力以及力矩平衡解出两个滑动铰支座的内力（或悬臂梁的约束力和约束力矩）。 把梁上作用的力，力矩，载荷以及载荷产生的力矩三者进行参数化建立关于他们对位置坐标 x 的密度函数。 利用力以及力矩平衡方程对密度函数进行积分求得剪力以及弯矩随位置 x 的分布函数。 利用弯矩与挠度的曲线的关系求解挠度曲线。 规定： 外力 ：向下为正 。 支座反力 ：向上为正。 外力矩 ：顺时针为正。 由受力平衡与力矩平衡可以解出任意截面内的剪力与弯矩。 其中: 由于挠度曲线二阶导 正比于弯矩 ，求得弯矩可以得到挠度曲线 程序实现：mathematica代码如下(EI 在假设为1 ，且梁的长度 设定为1 )： 外力及力矩： 以2*n数组给出，第一行为位置，第二行为大小 载荷： 以3*n的数组给出，第一行为载荷函数，输入格式为纯函数，第二行为载荷起点位置，第三行为载荷终点位置 支座位置： 以1*2数组给出，为两个支座位置 简支梁： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647Clear[\"*`\"];xb[F_, M_, Q_, X_] := Module[{force, moment, f0, m0, v, y, x, p, q}, force = Total[Last@F] + Total[MapThread[Integrate[#1[x], {x, #2, #3}] &amp;, Q]]; moment = Total[MapThread[#1*#2 &amp;, F]] + Total[Last@M] + Total[MapThread[Integrate[#1[x]*x, {x, #2, #3}] &amp;, Q]]; sol = Solve[{p + q == force, X[[1]]*p + X[[2]]*q == moment}, {p, q}]; p = p /. sol[[1, 1]]; q = q /. sol[[1, 2]]; f0 = Integrate[(p*DiracDelta[x - X[[1]]] + q*DiracDelta[x - X[[2]]] + Total[MapThread[-#2*DiracDelta[x - #1] &amp;, F]] + force*DiracDelta[x] - Total[MapThread[#1[ x]*(HeavisideTheta[x - #2] - HeavisideTheta[x - #3]) &amp;, Q]]), x]; m0 = Integrate[(Total[MapThread[x*#2*DiracDelta[x - #1] &amp;, F]] + Total[ MapThread[ x*#1[x]*(HeavisideTheta[x - #2] - HeavisideTheta[x - #3]) &amp;, Q]] + Total[MapThread[#2*DiracDelta[x - #1] &amp;, M]] - x*(p*DiracDelta[x - X[[1]]] + q*DiracDelta[x - X[[2]]])), x] + f0*x; sol = DSolve[{y''[x] == m0, y[X[[1]]] == 0, y[X[[2]]] == 0}, y[x], x]; v = -y[x] /. sol[[1]]; Grid[{{\"剪力图\", Plot[f0, {x, 0, 1}, FrameLabel -&gt; {\"x\", \"F\"}, PlotTheme -&gt; \"Detailed\", PlotLegends -&gt; \"F(x)\", PlotLabel -&gt; Style[\"剪力图\", Bold], Exclusions -&gt; None, PlotStyle -&gt; Red]}, {\"弯矩图\", Plot[m0, {x, 0, 1}, FrameLabel -&gt; {\"x\", \"M\"}, PlotTheme -&gt; \"Detailed\", PlotLegends -&gt; \"M(x)\", PlotLabel -&gt; Style[\"弯矩图\", Bold], Exclusions -&gt; None, PlotStyle -&gt; Green]}, {\"挠度曲线\", Plot[-v, {x, 0, 1}, AxesLabel -&gt; {\"x\", \"y\"}, PlotTheme -&gt; \"Detailed\", PlotLabel -&gt; \"挠度曲线\", PlotLegends -&gt; \"y(x)\", FrameLabel -&gt; {\"x\", \"y\"}, PlotStyle -&gt; Blue, PlotRange -&gt; All]}}, Frame -&gt; All] ] 悬臂梁： 12345678910111213141516171819202122232425262728293031323334353637Clear[\"*`\"];xb[F_, M_, Q_] := Module[{force, moment, f0, m0, v, y, x}, force = Total[Last@F] + Total[MapThread[Integrate[#1[x], {x, #2, #3}] &amp;, Q]]; moment = Total[MapThread[#1*#2 &amp;, F]] + Total[Last@M] + Total[MapThread[Integrate[#1[x]*x, {x, #2, #3}] &amp;, Q]]; f0 = Integrate[(Total[MapThread[-#2*DiracDelta[x - #1] &amp;, F]] + force*DiracDelta[x] - Total[MapThread[#1[ x]*(HeavisideTheta[x - #2] - HeavisideTheta[x - #3]) &amp;, Q]]), x]; m0 = Integrate[(Total[MapThread[x*#2*DiracDelta[x - #1] &amp;, F]] - moment*DiracDelta[x] + Total[MapThread[ x*#1[x]*(HeavisideTheta[x - #2] - HeavisideTheta[x - #3]) &amp;, Q]] + Total[MapThread[#2*DiracDelta[x - #1] &amp;, M]]), x] + f0*x; sol = DSolve[{y''[x] == -m0, y[0] == 0, y'[0] == 0}, y[x], x]; v = -y[x] /. sol[[1]]; Grid[{{\"剪力图\", Plot[f0, {x, 0, 1}, FrameLabel -&gt; {\"x\", \"F\"}, PlotTheme -&gt; \"Detailed\", PlotLegends -&gt; \"F(x)\", PlotLabel -&gt; Style[\"剪力图\", Bold], Exclusions -&gt; None, PlotStyle -&gt; Red]}, {\"弯矩图\", Plot[m0, {x, 0, 1}, FrameLabel -&gt; {\"x\", \"M\"}, PlotTheme -&gt; \"Detailed\", PlotLegends -&gt; \"M(x)\", PlotLabel -&gt; Style[\"弯矩图\", Bold], Exclusions -&gt; None, PlotStyle -&gt; Green]}, {\"挠度曲线\", Plot[v, {x, 0, 1}, AxesLabel -&gt; {\"x\", \"y\"}, PlotTheme -&gt; \"Detailed\", PlotLabel -&gt; \"挠度曲线\", PlotLegends -&gt; \"y(x)\", FrameLabel -&gt; {\"x\", \"y\"}, PlotStyle -&gt; Blue]}}, Frame -&gt; All] ] 给出绘图的函数，可用于绘制标准的梁受力示意图（示意图中物理量大小输入最好由±1代替）： 简支梁： 12345678910111213141516171819202122232425262728293031323334353637Clear[\"`*\"];cp[F_, M_, Q_, X_] := Module[{wall, beam, moment, force, label, load}, wall = {Triangle[{{X[[1]], 0}, {X[[1]] - 0.01, -0.01*Sqrt[3]}, {X[[1]] + 0.01, -0.01* Sqrt[3]}}], Triangle[ {{X[[2]], 0}, {X[[2]] - 0.01, -0.01*Sqrt[3]}, {X[[2]] + 0.01, -0.01* Sqrt[3]}}]}; beam = {Thick, Line[{{0, 0}, {1, 0}}]}; circle[x_, n_] := Module[{k}, If[n == 1, Arrow@ Table[{x + 0.03*Cos[k], 0.03*Sin[k]}, {k, 0, 1.5*Pi, 0.1 Pi}], Arrow@ Table[{x + 0.03*Cos[k], 0.03*Sin[k]}, {k, 1.5*Pi, 0, -0.1 Pi}]]]; force = {Red, MapThread[Arrow[{{#1, 0}, {#1, 0.1*#2}}] &amp;, F]}; moment = {Green, Evaluate[MapThread[circle[#1, #2] &amp;, M]]}; label = MapThread[ Text, {Subscript[\"F\", #] &amp; /@ Range[Length[First@F]], Transpose[{First@F + 0.04, (#*0.13)/Abs[#] &amp; /@ Last@F}]}]~ Join~MapThread[ Text, {Subscript[\"M\", #] &amp; /@ Range[Length[First@M]], Transpose[{First@M, (Abs[#]*0.05)/Abs[#] &amp; /@ Last@M}]}]~Join~ MapThread[Text, {Subscript[\"q\", #] &amp; /@ Range[Length[First@Q]], MapThread[{(#2 + #3)/2 + 0.02, Sign[#1[(#2 + #3)/2]]*0.15 } &amp;, Q]}]; load = {Blue, Thin, Arrowheads[0.02], MapThread[ Arrow /@ Table[{{x, 0.08*#1[x]/Abs@Max[#1 /@ Range[#2, #3, (#3 - #2)/10]]}, {x, 0}}, {x, #2, #3, (#3 - #2)/5}] &amp;, Q]}; Show[Graphics[{Arrowheads[0.02], wall, moment, force, beam, label, load}]]]; 悬臂梁： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869Clear[\"`*\"];cp[F_, M_, Q_] := Module[{wall, beam, moment, force, label, load}, wall = {Line[{{0, 0.2}, {0, -0.2}}], Line /@ Transpose@{Transpose[{0*Range[10], 0.2 - 0.04*(Range@10 - 1)}], Transpose[{ConstantArray[-0.03, 10], 0.15 - 0.04*(Range@10 - 1)}]}}; beam = {Thick, Line[{{0, 0}, {1, 0}}]}; circle[x_, n_] := Module[{k}, If[n == 1, Arrow@ Table[{x + 0.03*Cos[k], 0.03*Sin[k]}, {k, 0, 1.5*Pi, 0.1 Pi}], Arrow@ Table[{x + 0.03*Cos[k], 0.03*Sin[k]}, {k, 1.5*Pi, 0, -0.1 Pi}]]]; force = {Red, MapThread[Arrow[{{#1, 0}, {#1, 0.1*#2}}] &amp;, F]}; moment = {Green, Evaluate[MapThread[circle[#1, #2] &amp;, M]]}; label = MapThread[ Text, {Subscript[\"F\", #] &amp; /@ Range[Length[First@F]], Transpose[{First@F + 0.04, (#*0.13)/Abs[#] &amp; /@ Last@F}]}]~ Join~MapThread[ Text, {Subscript[\"M\", #] &amp; /@ Range[Length[First@M]], Transpose[{First@M, (Abs[#]*0.05)/Abs[#] &amp; /@ Last@M}]}]~Join~ MapThread[Text, {Subscript[\"q\", #] &amp; /@ Range[Length[First@Q]], MapThread[{(#2 + #3)/2 + 0.02, Sign[#1[(#2 + #3)/2]]*0.15 } &amp;, Q]}]; load = {Blue, Thin, Arrowheads[0.02], MapThread[ Arrow /@ Table[{{x, 0.08*#1[x]/Abs@Max[#1 /@ Range[#2, #3, (#3 - #2)/10]]}, {x, 0}}, {x, #2, #3, (#3 - #2)/5}] &amp;, Q]}; Show[Graphics[{Arrowheads[0.02], wall, moment, force, beam, label, load}]]]; 最后来几张效果图： 说明一下，剪力图，弯矩图，挠度曲线和受力图没有选用对应的参数，只是作为一个示意。","link":"/2022/03/18/%E7%94%A8mathematica%E5%AE%9E%E7%8E%B0%E5%89%AA%E5%8A%9B%E5%BC%AF%E7%9F%A9%E5%9B%BE%E7%9A%84%E8%A7%A3%E6%9E%90%E6%B1%82%E8%A7%A3%E4%BB%A5%E5%8F%8A%E7%A4%BA%E6%84%8F%E5%9B%BE%E7%BB%98%E5%88%B6/"},{"title":"用mathematica实现均值不等式可视化","text":"调和—几何—算数—平方不等式。 调和平均数，几何平均数，算术平均数，平方平均数之间又如下关系：（二元） 利用mathematica可以实现可视化： n代表不同的伪随机种子 12345678910111213141516171819202122232425262728Clear[\"`*\"];Manipulate[ Row[{scene = RandomInstance[ GeometricScene[{a, b, c, d, e, f, o}, {GeometricStep[{Triangle[{a, b, c}], CircleThrough[{a, b, c, e}, o], o == Midpoint[{a, b}], Line[{d, e}], Line[{a, d, o, b}], Line[{c, f, o}], GeometricAssertion[{Line[{a, b}], Line[{c, d}]}, \"Perpendicular\"], GeometricAssertion[{Line[{d, f}], Line[{c, o}]}, \"Perpendicular\"], GeometricAssertion[{Line[{a, b}], Line[{o, e}]}, \"Perpendicular\"] }, \"平均值不等式\"]} ], RandomSeeding -&gt; n ], {AA, BB, CC, DD} = {EuclideanDistance [d, e], EuclideanDistance [o, e], EuclideanDistance [d, c], EuclideanDistance [c, f]} /. scene[\"Points\"]; Column[{\" \\!\\(\\*SqrtBox[FractionBox[\\(\\*SuperscriptBox[\\(x\\), \\(2\\\\)] + \\*SuperscriptBox[\\(y\\), \\(2\\)]\\), \\(2\\)]]\\)=de=\" &lt;&gt; ToString[AA], \" \\!\\(\\*FractionBox[\\(x + y\\), \\(2\\)]\\)=oe=\" &lt;&gt; ToString[BB], \" \\!\\(\\*SqrtBox[\\(xy\\)]\\)=cd=\" &lt;&gt; ToString[CC], \" \\!\\(\\*FractionBox[\\(2 xy\\), \\(x + y\\)]\\)=cf=\" &lt;&gt; ToString[DD]}]}] , {n, 1, 10, 1}, ControlPlacement -&gt; Top]","link":"/2022/03/18/%E7%94%A8mathematica%E5%AE%9E%E7%8E%B0%E5%9D%87%E5%80%BC%E4%B8%8D%E7%AD%89%E5%BC%8F%E5%8F%AF%E8%A7%86%E5%8C%96/"},{"title":"用mathematica推导与验证Bertrand定理","text":"Bertrand定理描述了闭合轨道条件下具有幂函数形式的有心力的可能情况 1公式推导Bertrand定理指出，对于有心力场，位势 ，只有当 时，运动轨道才是闭合的。 根据https://zh.wikipedia.org/wiki/%E4%BC%AF%E7%89%B9%E8%98%AD%E5%AE%9A%E7%90%86中的证明思路，可以利用mathematica进行推导。 代码: 1234567891011121314151617181920212223242526272829303132Clear[\"`*\"]J[x_] := A*x^(1 - \\[Beta]^2);ruleJ = First[Solve[D[J[x], x] == (1 - \\[Beta]^2), A]];rule1 := Table[Cos[k*\\[Beta]*\\[Theta]] -&gt; 0, {k, 1, 9}]rule2 = {h0 -&gt; A*h1^2, h2 -&gt; B*h1^2, h3 -&gt; F*h1^3}~Join~ Fold[ReplaceAll, {J1 -&gt; 1 - \\[Beta]^2, J2 -&gt; D[J[x], {x, 2}], J3 -&gt; D[J[x], {x, 3}]}, ruleJ~Append~(x -&gt; u0)]~Join~ Table[Power[h1, k] -&gt; 0, {k, 4, 9}];\\[Eta][\\[Theta]_] := h0 + h1*Cos[\\[Beta]*\\[Theta]] + h2*Cos[2*\\[Beta]*\\[Theta]] + h3*Cos[3*\\[Beta]*\\[Theta]]x = D[\\[Eta][\\[Theta]], {\\[Theta], 2}] + \\[Beta]^2*\\[Eta][\\[Theta]];y = TrigReduce[(1/2 \\[Eta][\\[Theta]]^2*J2 + 1/6 \\[Eta][\\[Theta]]^3*J3)];a = Coefficient[ x, {Cos[\\[Beta]*\\[Theta]], Cos[2 \\[Beta]*\\[Theta]], Cos[3 \\[Beta]*\\[Theta]]}];b = Coefficient[ y, {Cos[\\[Beta]*\\[Theta]], Cos[2 \\[Beta]*\\[Theta]], Cos[3 \\[Beta]*\\[Theta]]}];PrependTo[a, x /. rule1];PrependTo[b, y /. rule1];s = Fold[ReplaceAll, {a, b}, rule2];equ1 = MapThread[#1 == #2 &amp;, s];sol = Solve[equ1, {A, B, F, \\[Beta]}] 2 数值验证利用mathematica可以对Bertrand定理做出验证。 如图绘制了不同有心力 情况下的运动轨道。 可以发现只有 时，轨道才是闭合的。 图上传不了，分享个结果的pdf链接。 https://maiimg.com/pdf/?e=auNKkKmHMM43s6 代码： 123456789101112131415161718Clear[\"`*\"]F[x_, k_] := -400/x^k;equ[k_] := {\\[Rho]''[t] - \\[Theta]'[t]^2*\\[Rho][t] == F[\\[Rho][t], k], \\[Theta]''[t]*\\[Rho][t] + 2*\\[Theta]'[t]*\\[Rho]'[t] == 0, \\[Theta][0] == 0, \\[Rho][0] == 1, \\[Rho][0] \\[Theta]'[0] == 10, \\[Rho]'[0] == 10};sol[k_] := NDSolve[equ[k], {\\[Theta], \\[Rho]}, {t, 0, 10}];Grid[Partition[Table[ ParametricPlot[ Evaluate[{\\[Rho][t]*Cos[\\[Theta][t]], \\[Rho][t]* Sin[\\[Theta][t]]} /. First[sol[k]]], {t, 0, 10}, PlotRange -&gt; All, PlotTheme -&gt; \"Scientific\", PlotLabel -&gt; \"有心力场轨道 \\[Alpha]=\" &lt;&gt; ToString[k], FrameLabel -&gt; {\"x\", \"y\"}] , {k, -3.6, 2.7, 0.1}], 8], Frame -&gt; All]","link":"/2022/03/18/%E7%94%A8mathematica%E6%8E%A8%E5%AF%BC%E4%B8%8E%E9%AA%8C%E8%AF%81Bertrand%E5%AE%9A%E7%90%86/"},{"title":"用mathematica改写二部创意曲第八条","text":"Bach的音乐中有着对称美。 平移对称性体现在在不同的时间内交错地再现主题 反演对称性体现在利用倒影（旋转180°）手法创作其他声部 利用mathematica可以更加清楚的揭示声部之间的关系。 举个例子： 二部创意曲第八条 可以看出，上下两个声部几乎是完全一样的，只不过在时间维度上错开了。 利用mathematica可以对这一小段进行在创作 代码如下： 首先，把需要的音符和时值写进去123456789101112131415161718192021Clear[\"`*\"]{a, b, c, d} = 0.5*{1, 0.5, 0.25, 0.125};{c4, d4, e4, f4, g4, a4, b4} = {0, 2, 4, 5, 7, 9, 11};{c5, d5, e5, f5, g5, a5, b5} = {c4, d4, e4, f4, g4, a4, b4} + 12;{c6, d6, e6, f6, g6, a6, b6} = {c5, d5, e5, f5, g5, a5, b5} + 12;bb4 = 10;bb5 = 22;time1 = ConstantArray @@@ {{b, 7}, {c, 10}, {b, 6}, {c, 36}, {b, 6}, {c, 12}, {b, 1}, {c, 14}, {b, 1}, {c, 2}, {b, 8}, {a, 1}} // Flatten;note1 = {None, f4, a4, f4, c5, f4, f5, e5, d5, c5, d5, c5, bb4, a4, bb4, a4, g4, f4, a4, c5, a4, f5, c5, a5, c6, bb5, c6, a5, c6, bb5, c6, a5, c6, bb5, c6, f5, a5, g5, a5, f5, a5, g5, a5, f5, a5, g5, a5, d5, f5, e5, f5, d5, f5, e5, f5, d5, f5, e5, f5, b4, g4, d5, b4, f5, d5, g5, a5, g5, f5, e5, f5, e5, d5, c5, d5, c5, bb4, a4, d5, c5, b4, c5, b4, a4, g4, a4, g4, f4, e4, f4, e4, d4, c4, c5, b4, c5, e4, f4, c5, e4, c5, d4, b4, c5};然后，原曲（大概的，保持了两个声部的一致性）：12345Audio@Sound@MapThread[SoundNote[#1, #2, \"Piano\"] &amp;, {note1, time1}] + Audio@Sound@ MapThread[ SoundNote[#1, #2, \"Piano\"] &amp;, {Join[ConstantArray[None, 3], note1], Join[{a, a, a}, time1]}] 错开五度123456Audio@Sound@ MapThread[SoundNote[#1, #2, \"Piano\"] &amp;, {7 + note1, time1}] + Audio@Sound@ MapThread[ SoundNote[#1, #2, \"Piano\"] &amp;, {Join[ConstantArray[None, 3], note1], Join[{a, a, a}, time1]}] 错开四度123456Audio@Sound@ MapThread[SoundNote[#1, #2, \"Piano\"] &amp;, {5 + note1, time1}] + Audio@Sound@ MapThread[ SoundNote[#1, #2, \"Piano\"] &amp;, {Join[ConstantArray[None, 3], note1], Join[{a, a, a}, time1]}] 倒映12345Audio@Sound@MapThread[SoundNote[#1, #2, \"Piano\"] &amp;, {-note1, time1}] + Audio@Sound@ MapThread[ SoundNote[#1, #2, \"Piano\"] &amp;, {Join[ ConstantArray[None, 3], -note1], Join[{a, a, a}, time1]}] 这一段是不是有巴赫内味了？(இωஇ ) 两个声部互为倒映：12345Audio@Sound@MapThread[SoundNote[#1, #2, \"Piano\"] &amp;, {note1, time1}] + Audio@Sound@ MapThread[ SoundNote[#1, #2, \"Piano\"] &amp;, {Join[ ConstantArray[None, 3], -note1], Join[{a, a, a}, time1]}] 这个听起来不是很舒服。 除此之外，还可以用不同乐器演奏不同的声部，突出声部的独立性。123456Audio@Sound@ MapThread[SoundNote[#1, #2, \"Violin\"] &amp;, {12 - note1, time1}] + Audio@Sound@ MapThread[ SoundNote[#1, #2, \"Bassoon\"] &amp;, {Join[ConstantArray[None, 3], 7 - note1], Join[{a, a, a}, time1]}]用小提琴演奏高音声部，巴松演奏低音声部。 应该还有好多好玩的。 我创作了一段，第一段用原旋律＋平移对称性，第二段用倒映手法：12345678910Audio@Sound@ MapThread[ SoundNote[#1, #2, \"Violin\"] &amp;, {7 + note1~Join~(7 - note1), time1~Join~time1}] + Audio@Sound@ MapThread[ SoundNote[#1, #2, \"Piano\"] &amp;, {Join[ConstantArray[None, 3], note1]~Join~ Join[ConstantArray[None, 3], 12 - note1], Join[{a, a, a}, time1]~Join~Join[{a, a, a}, time1]}]是不是感觉和这首管风琴奏鸣曲的手法很像？ bwv525, 也是旋律＋倒映分为两段进行拼接的。 看第三乐章： 第一段：第二段：","link":"/2022/07/18/%E7%94%A8mathematica%E6%94%B9%E5%86%99%E4%BA%8C%E9%83%A8%E5%88%9B%E6%84%8F%E6%9B%B2%E7%AC%AC%E5%85%AB%E6%9D%A1/"},{"title":"用mathematica求解相对追逐问题","text":"相对追逐问题：几个人处于n边形的定点上，前一个人朝着后一个人运动。详情见https://en.wikipedia.org/wiki/Mice_problem 理论上可以证明，追踪曲线解析解为对数螺线。 利用mathematica可以依次数值求解微分方程绘制轨迹曲线。 12345678910111213141516171819Clear[\"`*\"]n = 10;a = CirclePoints[n];b = 0.1;equ = Flatten@ Table[{Sqrt[y[k]'[t]^2 + x[k]'[t]^2] == b, (y[Mod[k + 1, n, 1]][t] - y[k][t])* D[x[k][t], t] == (x[Mod[k + 1, n, 1]][t] - x[k][t])* D[y[k][t], t], Thread[{x[k][0], y[k][0]} == a[[k]]], Thread[{x[k]'[0], y[k]'[0]} == b*Normalize[a[[Mod[k + 1, n, 1]]] - a[[k]]]]}, {k, 1, n}];sol = NDSolve[equ, Flatten[{x[#], y[#]} &amp; /@ Range@n], {t, 0, 32}, Method -&gt; {\"EquationSimplification\" -&gt; \"Residual\"}] // Flatten;Plot[Evaluate@Through[Values[sol][t]], {t, 0, 32}, ImageSize -&gt; Large]Show[{ParametricPlot[ Evaluate@Partition[Through[Values[sol][t]], 2], {t, 0, 30}, PlotTheme -&gt; \"Scientific\", PlotLabel -&gt; \"Bugs' movation\", FrameLabel -&gt; {\"x\", \"y\"}] , Graphics[Line[Append[CirclePoints[n], First@CirclePoints[n]]]]}]","link":"/2022/03/18/%E7%94%A8mathematica%E6%B1%82%E8%A7%A3%E7%9B%B8%E5%AF%B9%E8%BF%BD%E9%80%90%E9%97%AE%E9%A2%98/"},{"title":"用mathematica计算微分几何中的部分量","text":"mathematica在微分几何中的几个应用： 动态绘制空间曲线的密切平面 求曲面中的一些基本量 求曲面第一基本形式 求曲面第二基本形式 求曲面向量两个方向夹角 求曲面域的面积 动态绘制Dipan指标线 动态绘制空间曲线密切平面123456789101112131415Clear[\"`*\"]f[x_, y_, z_, t0_] := Block[{X, Y, Z}, Dot[Cross[{x'[t0], y'[t0], z'[t0]}, {x''[t0], y''[t0], z''[t0]}], {X - x[t0], Y - y[t0], Z - z[t0]}]]Manipulate[ Show[{ParametricPlot3D[{Cos[k], Sin[k], k}, {k, -\\[Pi], \\[Pi]}, PlotRange -&gt; {{-3, 3}, {-3, 3}, {-4, 4}}, Boxed -&gt; False, Axes -&gt; False], ContourPlot3D[ f[Cos, Sin, # &amp;, t] == 0, {X, Cos[t] - 0.5, Cos[t] + 0.5}, {Y, Sin[t] - 0.5, Sin[t] + 0.5}, {Z, t - 0.5, t + 0.5}], ListPointPlot3D[{{Cos[t], Sin[t], t}}, PlotStyle -&gt; {Red, PointSize[Large]}]}] , {t, -\\[Pi], \\[Pi]}] 曲面论求曲面基本参数，第一、第二基本形式，方向角、曲面域的面积1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950Clear[\"`*\"]SurfaceParameters[r_] := Block[{n, E1, F1, G1, L2, M2, N2, u, v}, n = Normalize[Cross[D[r[u, v], u], D[r[u, v], v]]]; E1 = Dot[D[r[u, v], u], D[r[u, v], u]]; F1 = Dot[D[r[u, v], u], D[r[u, v], v]]; G1 = Dot[D[r[u, v], v], D[r[u, v], v]]; L2 = Dot[n, D[r[u, v], {u, 2}]]; M2 = Dot[n, D[D[r[u, v], v], u]]; N2 = Dot[n, D[r[u, v], {v, 2}]]; Grid[{{\"E\", \"F\", \"G\", \"L\", \"M\", \"N\"}, {E1, F1, G1, L2, M2, N2}} // Simplify[#, {u, v} \\[Element] PositiveReals] &amp;, Frame -&gt; All]]FirstBasicForm[r_] := Block[{u, v, du, dv}, n = Normalize[Cross[D[r[u, v], u], D[r[u, v], v]]]; E1 = Dot[D[r[u, v], u], D[r[u, v], u]]; F1 = Dot[D[r[u, v], u], D[r[u, v], v]]; G1 = Dot[D[r[u, v], v], D[r[u, v], v]]; (E1*du^2 + 2*F1*du*dv + G1*dv^2) // Simplify[#, {u, v} \\[Element] PositiveReals] &amp;]SecondBasicForm[r_] := Block[{u, v, du, dv}, n = Normalize[Cross[D[r[u, v], u], D[r[u, v], v]]]; L2 = Dot[n, D[r[u, v], {u, 2}]]; M2 = Dot[n, D[D[r[u, v], v], u]]; N2 = Dot[n, D[r[u, v], {v, 2}]]; (L2*du^2 + 2*M2*du*dv + N2*dv^2) // Simplify[#, {u, v} \\[Element] PositiveReals] &amp;]SurfaceAngle[r_, r0_, r1_, r2_] := Block[{du, dv, \\[Delta]u, \\[Delta]v, u, v}, E1 = Dot[D[r[u, v], u], D[r[u, v], u]]; F1 = Dot[D[r[u, v], u], D[r[u, v], v]]; G1 = Dot[D[r[u, v], v], D[r[u, v], v]]; ReplaceAll[ ArcCos[(E1*du*\\[Delta]u + F1*(du*\\[Delta]v + dv*\\[Delta]u) + G1*dv*\\[Delta]v)/(Sqrt[E1*du^2 + 2*F1*du*dv + G1*dv^2]*Sqrt[ E1*\\[Delta]u^2 + 2*F1*\\[Delta]u*\\[Delta]v + G1*\\[Delta]v^2])], {du -&gt; r1[[1]], dv -&gt; r1[[2]], \\[Delta]u -&gt; r2[[1]], \\[Delta]v -&gt; r2[[2]], u -&gt; r0[[1]], v -&gt; r0[[2]]}]]ManifoldArea[r_, R1_, R2_] := Block[{u, v}, E1 = Dot[D[r[u, v], u], D[r[u, v], u]]; F1 = Dot[D[r[u, v], u], D[r[u, v], v]]; G1 = Dot[D[r[u, v], v], D[r[u, v], v]]; Integrate[Sqrt[ E1*G1 - F1^2], Prepend[R1, u], Prepend[R2, v]]] 一些测试范例123456789101112131415161718192021SurfaceAngle[{Cos[#2]*#1, Sin[#2] #1, 3*#2} &amp;, {3, 1}, {1, 1}, {-1, 1}] // NSimplify[FirstBasicForm[{Cos[#2]*#1, Sin[#2] #1, a*#2} &amp;], {a, Cos[v]} \\[Element] Reals];Simplify[SecondBasicForm[{Cos[#2]*#1, Sin[#2] #1, a*#2} &amp;], {a, Cos[v], Sin[v]} \\[Element] PositiveReals];Simplify[SurfaceParameters[ R*{Cos[#2]*Cos[#1], Sin[#1]*Cos[#2], Sin[#2]} &amp;], {R, u, v, Cos[v]} \\[Element] PositiveReals];Simplify[SurfaceParameters[{a*#2*Cos[#1], a*#2*Sin[#1], a*#2^2} &amp;], {a, u, v} \\[Element] PositiveReals];ManifoldArea[ R*{Cos[#2]*Cos[#1], Sin[#1]*Cos[#2], Sin[#2]} &amp;, {0, 2 \\[Pi]}, {-\\[Pi]/2, \\[Pi]/2}] // Simplify[#, R &gt; 0] &amp;;FirstBasicForm[{#1 Cos[#2], #1 Sin[#2], #1 + #2} &amp;];FirstBasicForm[{#2 Cos[#1], #2 Sin[#1], Sqrt[#2^2 - 1]} &amp;] /. {u -&gt; ArcTan[x] + y, v -&gt; Sqrt[x^2 + 1], du -&gt; 1/(1 + x^2) dx + dy, dv -&gt; (x*dx)/Sqrt[x^2 + 1]} // Simplify;Simplify[SecondBasicForm[{R*Cos[#2] Cos[#1], R*Cos[#2]*Sin[#1], R*Sin[#2]} &amp;], {R, u, v, Cos[u], Sin[u], Cos[v], Sin[v]} \\[Element] PositiveReals] 切平面与法线1234567891011121314151617TangentPlane[r_, r0_] := Block[{u, v}, Det[{{X, Y, Z} - r @@ r0, D[r @@ {u, v}, u], D[r @@ {u, v}, v]} /. {u -&gt; r0[[1]], v -&gt; r0[[2]]}] == 0 // Simplify]CurveNormal[r_, r0_] := Block[{u, v}, ((X - (r @@ r0)[[1]])/ Det[{{D[r @@ {u, v}, u][[2]], D[r @@ {u, v}, v][[2]]}, {D[r @@ {u, v}, u][[3]], D[r @@ {u, v}, v][[3]]}}] == (Y - (r @@ r0)[[2]])/ Det[{{D[r @@ {u, v}, u][[3]], D[r @@ {u, v}, v][[3]]}, {D[r @@ {u, v}, u][[1]], D[r @@ {u, v}, v][[1]]}}] == (Z - (r @@ r0)[[3]])/ Det[{{D[r @@ {u, v}, u][[1]], D[r @@ {u, v}, v][[1]]}, {D[r @@ {u, v}, u][[2]], D[r @@ {u, v}, v][[2]]}}])] 测试范例1234567891011121314*范例*TangentPlane[{a*Cos[#1]*Cos[#2], a*Cos[#2]*Sin[#1], a*Sin[#2]} &amp;, {\\[Phi], \\[Theta]}]CurveNormal[{a*Cos[#1]*Cos[#2], a*Cos[#2]*Sin[#1], a*Sin[#2]} &amp;, {\\[Phi], \\[Theta]}] // SimplifyManipulate[ ContourPlot3D[ a Cos[\\[Theta]]*\\[Theta]* (a - Z Sin[\\[Theta]] - Cos[\\[Theta]] (X Cos[\\[Phi]] + Y Sin[\\[Phi]])) == 0, {X, -1, 1}, {Y, -1, 1}, {Z, -1, 1}] /. a -&gt; 1, {\\[Theta], -\\[Pi], \\[Pi]}, {\\[Phi], -\\[Pi], \\[Pi]}]ParametricPlot3D[{Cos[#1] #1*Cos[#2], #2 Cos[#2]*Sin[#1], Sin[#2]} &amp; @@ {\\[Phi], \\[Theta]}, {\\[Phi], -\\[Pi], \\[Pi]}, {\\\\[Theta], -\\[Pi], \\[Pi]}] /. a -&gt; 1 Dipan指标线1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Clear[\"`*\"]Dupin[r_, r0_] := Block[{u, v, x, y, \\[Rho], t}, n = Normalize[Cross[D[r[u, v], u], D[r[u, v], v]]]; L2 = Dot[n, D[r[u, v], {u, 2}]]; M2 = Dot[n, D[D[r[u, v], v], u]]; N2 = Dot[n, D[r[u, v], {v, 2}]]; sol = Solve[ Evaluate[(L2*x^2 + 2*M2*x*y + N2*y^2) /. {Abs[x_] -&gt; x, x -&gt; \\[Rho]*Cos[t], y -&gt; \\[Rho]*Sin[t]}] == 1, \\[Rho]] ; s = RotationTransform[{{0, 0, 1}, n}][{Abs[\\[Rho] /. sol[[1]]]* Cos[t], Abs[\\[Rho] /. sol[[1]]]*Sin[t], 0}]; TranslationTransform[ Dot[r @@ r0 - s /. t -&gt; 1, n /. {u -&gt; r0[[1]], v -&gt; r0[[2]]}]* n /. {u -&gt; r0[[1]], v -&gt; r0[[2]]}][s]]TangentPlane[r_, r0_] := Block[{u, v}, Det[{{X, Y, Z} - r @@ r0, D[r @@ {u, v}, u], D[r @@ {u, v}, v]} /. {u -&gt; r0[[1]], v -&gt; r0[[2]]}] == 0 // Simplify]Show[ {ParametricPlot3D[{Cos[u], Cos[v], Cos[u + v]}, {u, 0, 2 \\[Pi]}, {v, 0, 2 \\[Pi]}, PlotRange -&gt; 3, Boxed -&gt; False, Axes -&gt; None, Mesh -&gt; None], ParametricPlot3D[ Evaluate[ Dupin[{Cos[#1], Cos[#2], Cos[#1 + #2]} &amp;, {u, v}] /. {u -&gt; 1.5, v -&gt; 1}], {t, -\\[Pi], \\[Pi]}, PlotStyle -&gt; Red], ContourPlot3D[ Evaluate[ TangentPlane[{Cos[#1], Cos[#2], Cos[#1 + #2]} &amp;, {1.5, 1}]], {X, -4, 4}, {Y, -4, 4}, {Z, -4, 4}, Mesh -&gt; None, BoundaryStyle -&gt; None, ContourStyle -&gt; {Opacity[0.3], Green}], Graphics3D[{PointSize[Large], Red, Point[{Cos[#1], Cos[#2], Cos[#1 + #2]} &amp; @@ {1.5, 1}]}]}]Manipulate[Show[ {ParametricPlot3D[{Cos[u], Cos[v], Cos[u + v]}, {u, 0, 2 \\[Pi]}, {v, 0, 2 \\[Pi]}, PlotRange -&gt; 4, Boxed -&gt; False, Axes -&gt; None, Mesh -&gt; None], ParametricPlot3D[ Evaluate[ Dupin[{Cos[#1], Cos[#2], Cos[#1 + #2]} &amp;, {u, v}] /. {u -&gt; u0, v -&gt; v0}], {t, -\\[Pi], \\[Pi]}, PlotStyle -&gt; Red], ContourPlot3D[ Evaluate[ TangentPlane[{Cos[#1], Cos[#2], Cos[#1 + #2]} &amp;, {u0, v0}]], {X, -4, 4}, {Y, -4, 4}, {Z, -4, 4}, Mesh -&gt; None, BoundaryStyle -&gt; None, ContourStyle -&gt; {Opacity[0.3], Green}], Graphics3D[{PointSize[Large], Red, Point[{Cos[#1], Cos[#2], Cos[#1 + #2]} &amp; @@ {u0, v0}]}]}], {u0, 0.1, 2 \\[Pi]}, {v0, 0.1, 2 \\[Pi]}, ControlPlacement -&gt; Top]","link":"/2022/07/18/%E7%94%A8mathematica%E8%AE%A1%E7%AE%97%E5%BE%AE%E5%88%86%E5%87%A0%E4%BD%95%E4%B8%AD%E7%9A%84%E9%83%A8%E5%88%86%E9%87%8F/"},{"title":"纪念博客开通的第一天~","text":"第一次看到个人博客比特之理，让我萌生了制作个人博客的想法。最令人不爽的是，自己以前学习不善于总结。有些时候学过一些东西，或许有感悟，但是时间一长，很多想法根本无法发挥他们的价值，而且之前也没有很好的总结，很多时间被白白的浪费了(⊙﹏⊙)。于是，我想在自己的网站中把生活中的一些感悟与思考总结起来，包括但不限于： 生活感悟 钢琴&amp;长笛 基础数学、物理 基础力学 mathematica MD DFT","link":"/2022/01/29/%E7%BA%AA%E5%BF%B5%E5%8D%9A%E5%AE%A2%E5%BC%80%E9%80%9A%E7%9A%84%E7%AC%AC%E4%B8%80%E5%A4%A9~/"},{"title":"练习和听过的音乐","text":"备份一下，防止丢失","link":"/2022/08/28/%E7%BB%83%E4%B9%A0%E5%92%8C%E5%90%AC%E8%BF%87%E7%9A%84%E9%9F%B3%E4%B9%90/"},{"title":"莱布尼茨公式为什么和二项式定理相似？","text":"偶然发现了这个有趣的类比~~在高等数学中，莱布尼茨公式非常常见。但是，作为工科学生，在工科数学分析基础上没看到证明。作为一个不严格的理解，记录如下。Leibniz公式Leibniz公式与二项式定理很像，那么他们又有什么关系呢？一个有趣的想法是，可以定义一种算子: 。 一般的，我们定义一种东西，是因为他可以符合某种好的性质。 那么这个算子的性质: 只与u作用，与ν不作用，对称的， 也只与v作用，与u不作用。他们与函数作用的结果是对这个函数求导。n个 依次与u作用，表示对u求n阶导，可以记为 ， 也同理。 这样就清楚了: 如果我想对uv乘积进行求导，我就把它记为: 对uv想求二阶导就对原有的一阶导再乘以 ，即 ， 不难验证这样写法是正确的（归纳法）。 如果n阶导数的话，就有: 小结 初看Leibniz公式与二项式定理很像，但是为什么还是值得思考的。如果不是两个函数相乘而是很多个。那么，就可以定义很多类似于 的东西，推广出来应该就是广义二项式定理。 其实，这个问题从高中就开始困扰我，知道大学才明白一点。 容易发现，导数的线性性质在这里表现为乘法的分配律。","link":"/2022/03/18/%E8%8E%B1%E5%B8%83%E5%B0%BC%E8%8C%A8%E5%85%AC%E5%BC%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%92%8C%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86%E7%9B%B8%E4%BC%BC%EF%BC%9F/"},{"title":"网上公众号所有的LAMMPS学习资源","text":"网络上公众号所有LAMMPS相关文章汇总 Coarse GrainBulk amorphous polymer模型的建立CHARMM-GUI构建简单聚合物的lammps模拟文件（charmm力场）Chain Alignment Parameter （链取向参数）Cu-Ni FGMs （Cu-Ni梯度合金的原子建模）GOPY：构建石墨烯的二维计算模型Glass Transition TemperatureGlass Transition Temperature — MD simulationGraphene-Polymer-Graphene模型Graphene-Polymer-Graphene模型Graphene-Polymer-Graphene模型（1）Graphene-Polymer-Graphene模型（1）Graphene拔出的分子动力学模拟-Graphene几何形状的影响HOOMD-blue：用于高性能分子动力学和硬粒子蒙特卡罗模拟的Python包LAMMPS —— fix/deformLAMMPS多任务运行LAMMPS常见错误— data 文件的格式LAMMPS模拟案例：受限于石墨烯纳米缝中的水LJ unit （Reduced Unit）LiPyphilic: 用于脂质膜模拟分析的Python工具包LigParGen &amp; Tinker —— OPLS-AA力场MARTINI 生物分子（及传统polymer）力场MDTraj：Python包，用于处理、分析分子动力学轨迹MD_MacromoleculesMD_MacromoleculesMagic —— 多尺度建模软件包Microstructural Rheology and Mesoscale Modeling — 康奈尔大学Joo课题组Nanopillar surface wetting —— 基底的建模Nature Materials文献推荐：Computational materials designNotepad++ 高亮显示LAMMPS文件PPT实现文章高分辨率配图PS粗粒化模拟——机械性能研究Peptoid Nanosheets —— ModelingPolymer Nanoparticle ModelPolymer+Particle复合材料体系建模（Python）PyLAT: Python LAMMPS分析工具Pysimm — 一个研究分子系统模拟的python包Python包—生成聚合物AA和CG模拟的输入参数和坐标Python生成polymer+ion体系，用于LAMMPS模拟Random_Walk Polymer模型Random_Walk Polymer模型（2）Random_Walk Polymer模型（2）Random_walk PE and Graphene层状复合材料（4）Random_walk PE 聚合物-石墨烯复合材料模型（3）Random_walk PE 聚合物-石墨烯复合材料模型（3）SHAKE algorithm —— LAMMPSVMD构建CNT，Graphene的LAMMPS data文件VOTCA —— 分子模拟+粗粒化建模分子模拟结果分析（1）：Persistent Homology —— HomCloud多晶和梯度多晶的建模强烈推荐，值得收藏： C，Si材料的粗粒化势函数和LAMMPS模拟文件排除体积 —— Excluded Volume文献分享: 用于合成聚合物建模和仿真的CHARMM-GUI聚合物生成器文献推荐：材料模拟概述文献解读：不同层数和层间距Cu/Ni复合材料的分子模型构建文献解读：石墨烯厚度和长度分布对石墨烯网络力学性能的影响——粗粒分子动力学模拟文献解读：碳纳米管增强铜纳米复合材料的拉伸响应：分子动力学模拟文献解读：碳纳米管增强铜纳米复合材料的拉伸响应：分子动力学模拟文献解读：碳纳米管增强铜纳米复合材料的拉伸响应：分子动力学模拟材料计算课题组石墨烯气凝胶力学性能和断裂行为的分子模拟研究石墨烯的粗粒化模型—1：孔片状石墨烯泡沫单轴超压缩和恢复行为的CGMD研究石墨烯的粗粒化模型—1：孔片状石墨烯泡沫单轴超压缩和恢复行为的CGMD研究石墨烯的粗粒化模型—2：石墨烯的粗粒化模型及其在复合材料中的应用石墨烯的粗粒化模型—2：石墨烯的粗粒化模型及其在复合材料中的应用石墨烯的粗粒化模型—3：Cu/Graphene复合材料的分子模型构建碳材料势函数（Interatomic potentials for carbon）碳纳米管(Carbon Nanotube, CNT)的粗粒化模型纳米材料建模器：CHARMM-GUI编制石墨烯的建模薄膜厚度和界面效应对聚合物薄膜动力学的影响铜/碳纳米管原子模型的构建铜/碳纳米管原子模型的构建隐式溶剂，以及溶剂质量调控非晶聚乙烯(Polyethylene, PE)的单轴拉伸模拟 LAMMPS(py)LIon: A package for simulating trapped ion trajectories2021年LAMMPS官方workshop开始2021年末总结2021材料大会LAMMPS相关海报（1）2021材料大会LAMMPS相关海报（2）2021材料大会LAMMPS相关海报（3）3D Peridynamic simulation的in文件3d-Crack模拟5年实验+3年模拟：纳米孔道钨薄膜中的氦行为研究AACSD：国产晶体结构、缺陷分析软件AMD Zen2架构处理器性能调优ATOMSK进行charge体系建模Atomsk与Voronoi多晶建模Atomsk建模系列教程1：软件安装Atomsk建模系列教程2：不同晶格类型晶体建模Atomsk建模系列教程3：石墨烯建模Atomsk建模系列教程4：单壁CNT建模Atomsk空位缺陷建模技巧Building metal alloy for LAMMPS using AtomskCarbon Foam的模拟CascadesDB：辐照模拟数据库DPD of surfactant self assembly using LAMMPSDeepMD势函数训练讲解ERROR: Bond atoms xxxx xxxx missing on proc x at step xxElectron Emission(bulk and 2D materials)Energy vs LatticeGRO2LAM：gromacs与lammps之间的转换工具High-Resolution Space Group Diagrams and TablesINTEL加速教程及GPU加速补充JAMIP：一款国产开源功能材料设计软件包L-J势参数获取脚本BUG说明LAMMPS Nanoindentation TutorialLAMMPS example：PourLAMMPS 教程之 molecule command 分子模板解析和举例LAMMPS-DSMC学习LAMMPS一核有难，九核围观？balance了解一下？LAMMPS中Tersoff等的势参数文件格式简介LAMMPS中的能量最小化操作LAMMPS做聚合物方向的模拟LAMMPS入门教程（1）——分子动力学模拟起源和LAMMPS简介LAMMPS入门教程（2）——从in文件建立讲分子动力学模拟流程LAMMPS入门教程（3）——从in文件建立讲分子动力学模拟流程LAMMPS入门教程（4）——LAMMPS并行版编译和运行LAMMPS入门讲解LAMMPS出错分析LAMMPS初学者教程（小结）LAMMPS到底能做些什么LAMMPS命令建模模板的完善（有修正）LAMMPS命令建模的一个小BUGLAMMPS命令建模示例（1）LAMMPS命令建模示例（2）LAMMPS命令建模示例（3）LAMMPS命令建模示例（4）LAMMPS命令构建分子模型LAMMPS和VASP初级使用教程LAMMPS回到未来计划LAMMPS学习系列LAMMPS学习系列（10）LAMMPS学习系列（11）LAMMPS学习系列（12）LAMMPS学习系列（13）LAMMPS学习系列（14）LAMMPS学习系列（15）LAMMPS学习系列（16）LAMMPS学习系列（17）LAMMPS学习系列（18）LAMMPS学习系列（19）LAMMPS学习系列（1）LAMMPS学习系列（20）LAMMPS学习系列（21小结）LAMMPS学习系列（22）LAMMPS学习系列（23）LAMMPS学习系列（23，已修改）LAMMPS学习系列（24）LAMMPS学习系列（25）LAMMPS学习系列（26）LAMMPS学习系列（27）LAMMPS学习系列（28）LAMMPS学习系列（29）LAMMPS学习系列（2）LAMMPS学习系列（30）LAMMPS学习系列（31）LAMMPS学习系列（33）：“幽灵”探针LAMMPS学习系列（34）:动态纳米压痕LAMMPS学习系列（35）：“静态”纳米压痕LAMMPS学习系列（36）LAMMPS学习系列（37）LAMMPS学习系列（38）LAMMPS学习系列（39）LAMMPS学习系列（3）LAMMPS学习系列（40）LAMMPS学习系列（41）LAMMPS学习系列（42）LAMMPS学习系列（43）LAMMPS学习系列（4）LAMMPS学习系列（5）LAMMPS学习系列（6）LAMMPS学习系列（7）LAMMPS学习系列（8）LAMMPS学习系列（9）LAMMPS完成reaxff模拟后统计产物分子LAMMPS官方教你使用minimizeLAMMPS官方最新“综述”LAMMPS官网里的宝藏信息（1）LAMMPS官网里的宝藏信息（2）LAMMPS官网里的宝藏信息（3）LAMMPS实践系列LAMMPS实践系列（1）LAMMPS实践系列（2）LAMMPS实践系列（3）LAMMPS实践系列（4）LAMMPS实践系列（5）LAMMPS小工具之PDB文件转reaxff所需要的dataLAMMPS平台搭建(WIN10)LAMMPS应用：LAMMPS模拟冲击压缩LAMMPS建模之moltemplate详细讲解LAMMPS教程之voronoi cell计算和输出LAMMPS构建金刚石切铜的初始模型LAMMPS案例收集： coarse-grained lipid bilayer membrane simulationsLAMMPS案例收集：Lammps-shear-viscosity-calculationLAMMPS案例收集：聚合物拉伸LAMMPS模拟TipsLAMMPS模拟in和data之纳米矩形超疏水结构表面液体流动的分子动力学模拟LAMMPS模拟教程和相关小工具LAMMPS模拟磁控溅射材料生长的in文件LAMMPS模拟过程和in与data文件建立系列教程LAMMPS的空间分配和通信算法LAMMPS经验谈（小结）LAMMPS网站打不开怎么办LAMMPS计算体积热容量LAMMPS计算声子谱相关程序的下载地址LAMMPS计算多晶Ni的杨氏模量（1）LAMMPS计算多晶Ni的杨氏模量（2）LAMMPS计算多晶Ni的杨氏模量（3）LAMMPS计算平衡晶格常数LAMMPS计算热导率的良心教程LAMMPS进阶教程之moltemplate建模得到data文件（1）LAMMPS进阶教程之我该怎么学LAMMPS？LAMMPS进阶教程原子近邻搜索LAMMPS里面的一个隐藏小BUGLAMMPS随机多孔结构建模LAMMPS静态计算之氧化镁中位错的原子尺度性质的研究Lammps使用经验谈之MATLAB后处理接口Lammps使用经验谈之MATLAB后处理接口(勘误)Lammps并行版安装教程：Ubuntu系统Lammps模型构建的方法之一：组合模型构建Lammps经验谈之opls-aa一文的补充说明Lammps经验谈之一个读log文件的m文件Lammps经验谈之基于matlab的数据前处理Lammps经验谈之指令解密之施加电场Lammps经验谈之指令解密之电极设置Lammps经验谈之指令解密之输出相互作用Lammps经验谈之指令解密之锯齿形设置Lammps经验谈之有机小分子建模及opls-aa力场使用Lammps经验谈之自动接续执行不同in文件小技巧Lammps经验谈之输出输出图片及视频Lammps经验谈之追踪个别原子运动轨迹Lammps经验谈之部分依赖包的安装Linux命令以及vi教程MD势能精讲第一篇：Lennard-Jones potentialMD势能精讲第二篇：EAM potentialMD模拟大牛：MIT李巨教授MD模拟时常用系综与对应脚本MD模拟时部分初始参数值的设置原则MD炫酷视频MD炫酷视频欣赏MD经典书籍介绍MD获取拉伸应力的两种方式及其转换关系MD计算单原子温度：理论与代码MD计算单晶Al广义堆垛层错能MPDI Coatings (IF: 2.881) 特刊征稿MS vs MDMS建模后快速导出LAMMPS可读取的格式MS构建水分子层并修改为lammps可读取的data文件的详细步骤Materials Studio多层聚合物的构建及data文件导出Materials studio中的简单聚合物的建立及盒子的弛豫Mishin大神教你用机器学习构建势Molecular dynamics simulations of iron-cementite nanoparticlesNEMD 温度梯度不正常或者Fix ehex kinetic energy went negativeNEMD方法计算热导率之langevin控温法NEMD过程 热源冷源有一端温度不下降或不上升NEMD遇到了热流不稳定，温度梯度不够好，能量不守恒该怎么办？Nature子刊：加速高熵合金的设计（速度远超mcsqs，含源码）Non-numeric box dimensions - simulation unstable 错误原因及解决办法Nonequilibrium free-energy calculations of fluids using LAMMPSOVITO。。。。不做图系列（1）OVITO中Dislocation analysis的用法OVITO中Displacement vectors的用法OVITO中文版手册OVITO作图系列（5）OVITO作图系列（6）OVITO作图系列（小结）OVITO后处理表征晶界迁移OVITO后处理计算位错速度OVITO处理RDF数据步骤OVITO导出非晶原子个数OVITO绘制文章级别的原子运动轨迹线OVITO缺陷分析视频教程OVITO：Python Script ModifierOVITO：操作介绍Ovito中多晶材料晶粒分析方法介绍Ovito做图系列（8）Ovito出图小妙招Ovito分析位错线长度和统计位错数量Ovito如何统计键角信息？Ovito绘制原子运动轨迹PPT必备：中国传统颜色的网站PyLAT: Python LAMMPS Analysis ToolsPython scripts for performing hybrid Monte Carlo with LAMMMPSPytim: A python package for the interfacial analysisReaxFF力场之Qeq电荷计算参数验证ReaxFF力场之键结参数验证-对比DFT和ReaxFFReaxFF力场公式介绍ReaxFF反应力场参数开发软件GARFfield下载和安装ReaxFF开发之GARFfield软件基本使用Reaxff力场文件获取途径Relaxation时在NVE系综下，total energy 一直上升的问题 2.0SCI论文引言要这样写，有仙剑味道的引言谁不爱呢Simon Gravelle大神最新教程：教你用vmd做高分辨图Simon大神最新教程Space Charge EffectsSurface Field Emission in 2D MaterialsTIP4P水分子lammps力场设置方法详解Using Ovito to Analyze a MD Simulation for Dislocation VelocityVMD视频教程VScode终极设置：永久自动识别lammps in文件方法Windows系统下Lammps自动接续执行不同in文件YouTube高赞MD模拟：一个简单又复杂的高压结晶模拟[lammps后处理]温度云图的绘制[lammps命令]thermo_style 命令详解（1）[lammps安装教程]lammps串行版安装教程[lammps安装教程]lammps并行版安装教程[lammps教程]OVITO绘制位移云图及矢量图[lammps教程]OVITO绘制原子应力云图[lammps教程]OVITO绘制原子运动轨迹线[lammps教程]OVITO输出RDF[lammps教程]分享一个比较实用的lammps/in文件模板[lammps案例分享]lammps颗粒浇注模拟[lammps案例分享]核壳结构破裂行为[lammps第七讲] 经典案例—石墨烯单轴拉伸[lammps第三讲] delete_atoms命令实现球壳结构建模[lammps第九讲] 复合材料/层合板结构建模[lammps第二十一讲]lammps动态负载均衡[lammps第二十讲]lammps二维维度模拟裂纹扩散[lammps第二讲] region命令实现六面体核壳结构建模[lammps第五讲] lammps建立纳米管模型[lammps第八讲] 合金拉升模拟[lammps第六讲] set命令建立高熵合金模型[lammps第十一讲] lammps多孔结构[lammps第十七讲]lammps统计原子个数[lammps第十七讲]铁球自由落体及回弹分子动力学模拟[lammps第十三讲]胶囊核壳结构建模/附OVITO渲染详细过程[lammps第十九讲]lammps原子沉积实例教程[lammps第十二讲]NiZr合金熔化及凝固lammps模拟[lammps第十五讲]lammps输出MSD（均方根位移）详解及示例教程[lammps第十八讲]wall/gran/region命令实现漏斗功能[lammps第十六讲]高熵合金熔炼过程分子动力学模拟[lammps第十四讲]lammps输出RDF（径向分布函数）详解及示例教程[lammps第十讲] CuNi合金熔化模拟[lammps第四讲] 复杂形状建模——胶囊粒子分子模型[lammps高阶案例]编织结构建模[分子动力学模拟资料]几种常用力场参数网站及LJ参数计算data文件获取之VMD软件fix atom/swap command的详解fix phonon命令中map_file文件的获取fix wall/reflect命令实现“振动墙”效果for their discoveries of receptors for temperature and touchin和data之SPC/E模型下水的表面张力计算in和data之三层石墨烯表面水块in和data之不同速度不同压力环境中的液滴对撞in和data之二元液滴撞击壁面自发移动的多体耗散粒子动力学模拟in和data之全氟聚醚OPLSAA力场生成工具in和data之分子刷表面润湿模拟in和data之剪切作用的两种实现方法及对比—Deform以及Velocityin和data之单轴压缩-应力应变曲线以及弹性模量计算in和data之多孔纳米通道简单液体渗透模拟in和data之小分子有机半导体的沉积的LAMMPS模拟in和data之巨正则蒙特卡洛—甲烷和二氧化碳的竞争吸附GCMCin和data之建模软件Enhanced Monte Carlo (EMC)in和data之循环定压比热熔计算in和data之拉伸、压缩、剪切、弯曲、扭转in和data之摩擦磨损还是摩擦焊的LAMMPS模拟in和data之有机分子热分解的ReaxFF模拟及活化能计算in和data之有趣的纳米“通道”—Lammps实现循环不同压痕深度in和data之氯化钠NaCl熔盐粘度和扩散系数模拟in和data之水分子穿孔扩散的分子动力学模拟in和data之水泥体系的钙矾石拉伸的LAMMPS模拟in和data之水溶液环境下离子液体在带电表面的吸附模拟in和data之水蒸气凝结的分子动力学模拟in和data之水铜纳米流体Green-Kubo计算热导率和粘度in和data之水铜纳米流体RNEMDS方法计算热导率和粘度in和data之沟槽表面固液气三相润湿in和data之油水界面的耗散粒子动力学模拟in和data之环氧树脂reaxff力场拉伸模拟in和data之石墨烯包裹纳米颗粒模拟in和data之石墨烯平板间[BMIM][PF6]离子液体in和data之硫化氢H2S表面张力模拟in和data之磁控颗粒输运液滴-LAMMPS模拟in和data之简单液体的纳米气泡形成in和data之粗糙表面的润湿行为模拟in和data之纳米压痕LAMMPS模拟in和data之纳米气泡电润湿形态变化in和data之纳米通道气水两相流in和data之纳米铜柱扭转和疲劳力学LAMMPS模拟in和data之聚乙二醇溶液in和data之计算多体耗散粒子动力学（MDPD）中液体的粘度in和data之超临界CO2驱替方英石纳米孔道内十二烷in和data之铁球在铁基底上摩擦的分子动力学模拟in和data之铝块的单轴压缩分子动力学模拟in和data之铝粉锻造LAMMPS模拟in和data和lt之一氧化碳CO多孔壁面上吸附和扩散in和data文件之FENE模型模拟高分子在微结构表面流动in和data文件之NaCl溶液液滴撞击固体表面in和data文件之冰块在阵列碳纳米管表面脱附过程的分子动力学模拟in和data文件之十六烷扩散系数和回转半径模拟in和data文件之固体颗粒非牛顿悬浮液耗散粒子动力学（DPD）模拟in和data文件之多体耗散粒子动力学（MDPD）表面张力模拟in和data文件之水滴润湿模拟-建模篇in和data文件之泰勒-库艾特流动MDPD模拟in和data文件之液滴定向移动的耗散粒子动力学（DPD）模拟in和data文件之液滴非均匀撞击润湿的多体耗散粒子动力学模拟in和data文件之离子液体建模教程in和data文件之简单液体流动传热in和data文件之简单液体边界滑移和热阻模拟（1）in和data文件之简单液体边界滑移和热阻模拟（2）in和data文件之纳米水泡的分子动力学模拟in和data文件之纳米水滴在沟槽表面撞击润湿模拟in和data文件之纳米流体（水+铜纳米颗粒）LAMMPS模拟in和data文件之纳米螺旋桨傻傻模拟in和data文件之聚氨酯中CO2气泡膨胀对聚氨酯形状的影响in和data文件之聚氨酯铝块三明治结构拉脱和剪切in和data文件之金属铜纳米压痕模拟in和data文件之铁块切削模拟in和data文件之铜块单轴拉伸到断裂in和data文件之铜纳米线撞击变形模拟in和data文件之镍圆柱撞击镍圆柱三种模拟设置in和data文件之长链聚合物data文件生成in和data文件之长链聚氨酯data文件生成in和data注射器的多体耗散粒子动力学模拟in和data纳米流体基本传热性质模拟in文件之热导率比热和粘度的计算命令in文件搜集：Si-Ar-Si heat transfer examplein文件的命令解析规则in文件：Coarse Grained Water Simulationin文件：Crumpling of a Graphene sheetin文件：Ice melting simulationin文件：Intrinsic-Stacking-Fault-Energyin文件：Polymer reptation (Lammps simulation)in文件：Silicon High Temperature Nano-indentation via LAMMPSkarl大神课题组网站（提供了一些与LAMMPS相关的小工具）lammps 2个温度修正命令，使模拟结果更精确lammps npt系综iso和aniso控压对比lammps 常用势函数设置方法lammps 建模方法汇总lammps 手册及不同版本下载备用地址lammps 案例lammps 案例（汇总）lammps 案例：CuZr合金建模以及融化固溶结晶过程模拟代码lammps 案例：C原子在Si基底沉积过程模拟案例学习lammps 案例：金球融化模拟代码练习lammps 案例：高熵合金FeNiCrCoCu建模及拉伸模拟代码lammps 调用python 和 shelllammps_interface MOF的自适配拓扑结构和力场转换开源工具lammpsprlammps不同类型data文件格式对比，以及不同类型data文件相互转换方法lammps中eam势在Xeon Platinum 8171M/RTX3060/RTX3080Ti计算速度对比lammps也玩凌波微步，原子组瞬间转移命令介绍lammps从高熵合金特定区域内选择某一种原子的技巧lammps入门指导lammps入门视频教程：Cu融化模拟代码编写及启动运算方法lammps内置的MC指令-获得成分稳定的初始构型lammps分子快捷分组方法介绍，氧化石墨烯+水体系平衡模拟案例lammps剪切模拟关键技术讲解lammps势函数设置lammps原子速度常用的几种设置方法lammps反应势Reaxff力场文件下载方法lammps反应势产物分析代码分享lammps后处理及使用技巧lammps后处理及技巧lammps后处理技巧：速度云图的绘制lammps后处理教程：slice命令实现局部剪切方法lammps后处理：ovito快速提取单条位错线的伯氏矢量lammps后处理：ovito选择原子高级技巧讲解lammps吸附模拟之CO2建模lammps命令建模示例（5）lammps命令建模示例（6）lammps基础命令及教程lammps基础教程lammps基础教程：Ovito标记原子内部运动方法介绍lammps如何排除两原子之间的受力，加快模拟速度，节省模拟时间lammps官网的logo动画是怎么做的呢lammps小技巧：如何把模拟结果单独存到一个文件夹lammps常用命令详解lammps常用的几种控温方式以及实现代码lammps常见设置误区：“刚体”和“固定”命令分不清lammps建模专题（1）lammps建模专题（2）lammps建模专题（3）lammps建模专题（4）lammps建模专题（5）lammps建模之圆柱形Ni与石墨烯层复合材料lammps建模及模拟教程lammps建模命令lattice custom案例详解lammps建模命令之lattice详解lammps建模小技巧：msi2lmp不能转换data文件的一种解决方法lammps建模技巧，read_data读入模型后新增其它类型原子2种方法lammps建模技巧：msi2lmp转换data文件结构错位解决办法lammps建模技巧：晶界偏析原子建模方法lammps建模方法lammps建模方法汇总lammps建模案例之NiTi合金建模lammps建模：Atmosk建立金属管道模型lammps建模：region union实现复杂形状建模lammps建模：倾斜圆锥刀具建模方法lammps建模：球壳模型建模方法lammps技巧：Out of range atoms - cannot compute PPPM原因分析及解决办法lammps技巧：原子位于box外面导致模拟出错的解决办法lammps教程：1D正弦粗糙界面建模建模教程（1）lammps教程：2D正弦粗糙界面建模建模教程（2）lammps教程：Atomsk任意角度晶界建模方法lammps教程：Atomsk建模方法（2）-孪晶模型lammps教程：Buckingham势设置方法lammps教程：Cu孪晶建模方法lammps教程：EAM势参数设置详解lammps教程：FeNiCr合金多晶结构建模方法lammps教程：H2氢气建模以及转化为data文件方法lammps教程：MS转data文件出错原因分析及解决办法lammps教程：MS转data文件另外一种简单方法lammps教程：Macbook Air M1安装lammps简单教程lammps教程：Morse势参数设置说明（附常见原子Morse势参数表）lammps教程：NEMD方法计算热导率公式详解lammps教程：OPLS势函数参数设置方法lammps教程：Ovito中多晶不同颜色显示技巧lammps教程：Ovito分析并绘制单原子应变方法介绍lammps教程：Ovito显示化学键的方法lammps教程：Ovito查看晶体内部变形方法lammps教程：Ovito设置原子不同透明度的小技巧lammps教程：Parrinello-Rahman控压参数设置lammps教程：Windows系统Zhou合金势拟合程序编译方法介绍lammps教程：atomsk多相建模方法lammps教程：bond 混合势设置两种方法lammps教程：boundary命令详解lammps教程：compute chunk/atom分块命令使用方法介绍lammps教程：compute group/group原子组相互作用计算方法lammps教程：create_atoms生成原子的4种方式lammps教程：create_box 命令详解lammps教程：cvff势函数参数设置方法lammps教程：delete_atoms 命令详解lammps教程：delete_atoms删除原子后原子ID不连续的两种解决方案lammps教程：dump_modify使模拟图像更美观lammps教程：fix setforce命令详解lammps教程：group命令详解lammps教程：hcp类型晶格建模缺陷及解决方案lammps教程：in文件结构详解以及一个比较实用的in文件模板lammps教程：linux系统一次提交多个in文件计算的方法lammps教程：lj/cut/coul力场参数设置详解lammps教程：lj/cut力场设置lammps教程：meam/c势函数设置详解lammps教程：minimize命令使用详解lammps教程：nve/nvt/npt系综设置方法lammps教程：ovito多晶显示方法lammps教程：ovito查看完整分子链方法lammps教程：pcff势函数参数设置方法lammps教程：read_data命令构建复杂组合模型lammps教程：real和metal单位下能量转换公式lammps教程：region plane命令建立锐角刀具模型lammps教程：replicate命令轻松实现阵列特征结构lammps教程：reset_timestep步数归零的作用以及使用方法lammps教程：restart重启计算命令用法详解lammps教程：run命令使用技巧，多次run正确写法lammps教程：units lattice和units box应该如何选择？lammps教程：velocity命令三种使用方法lammps教程：velocity拉伸“拉不动”的原因探讨及解决方案lammps教程：write_dump保存模拟快照lammps教程：“lost atoms”丢失原子错误原因及4种解决方案lammps教程：一次提交多个in文件计算的简单方法lammps教程：一种简单的合金化合物建模方法介绍（TiC为例）lammps教程：不同原子组势能计算方法lammps教程：以Cu纳米磨削为例详解region命令lammps教程：以计算Fe晶格常数为例介绍jump命令使用lammps教程：刃型位错线Atomsk建模方法详解lammps教程：分享一个六元高熵合金势CoNiVCrFeMnlammps教程：分享一组born势参数lammps教程：分享一组常用金属的晶格常数lammps教程：加热或冷却速率设置方法lammps教程：单原子应力计算及应力云图绘制方法lammps教程：单原子温度计算之温度云图绘制方法lammps教程：单原子温度计算及输出方法lammps教程：单原子的位移计算及云图绘制lammps教程：原子平动和振动的设置方法lammps教程：原子组整体漂移怎么办？lammps教程：变量前缀v_/c_/f_的用法lammps教程：叠加力场hybrid/overlay设置方法介绍lammps教程：合金体系牛顿层划分以及不同颜色显示方法lammps教程：圆角刀具建模方法lammps教程：均方位移MSD计算方法介绍lammps教程：增加真空层、改变box尺寸，change_box三种用法详解lammps教程：如何更清晰观察晶体结构？Ovito渲染技巧介绍lammps教程：如何计算单个原子的体积lammps教程：如果动态统计区域内的原子数量lammps教程：官方自带eam_database程序拟合EAM势方法介绍lammps教程：实例讲解npt、nvt系综的选择lammps教程：工件旋转设置方法lammps教程：常见运行错误及解决办法lammps教程：平均值输出fix ave/time命令详解lammps教程：应力-应变数据的计算与输出lammps教程：弹簧连接两个原子组的设置方法lammps教程：恒定电场及交变电场设置方法lammps教程：推荐一款比较好用的lammps in文件编辑器lammps教程：推荐几个比较实用的lammps自带函数lammps教程：推荐几个比较实用的lammps自带函数（2）lammps教程：改变原子类型之set命令详解lammps教程：晶体建模之Atomsk方法（1）lammps教程：晶向分布函数g(r)的计算与输出方法lammps教程：模拟量实时显示thermo命令详解（1）lammps教程：模拟量实时显示之thermo_style custom命令详解(2)lammps教程：磨屑原子Ovito后处理视频教程lammps教程：薄膜渗透模拟（3）—不同孔隙率对过滤效果的影响lammps教程：薄膜渗透过滤模拟(2)—平衡弛豫过程lammps教程：薄膜渗透过滤模拟（1）lammps教程：读取文件提示“Did not assign all atoms correctly”的解决办法lammps教程：非晶sio2建模方法lammps教程：高熵合金建模之set type/ratio命令lammps教程：高熵合金建模备用方法lammps案例之混合势函数设置详解（Al/Graphene复合物烧结）lammps案例分享：Al/聚氨酯界面模拟lammps案例分析（1）：石墨烯单轴拉伸之velocity方式lammps案例分析（2）：石墨烯单轴拉伸之deform方式lammps案例：Al冲击过程模拟案例代码lammps案例：CNT拉伸案例代码解析lammps案例：CO2扩散模拟案例代码lammps案例：Cu(111)表面能的计算lammps案例：Cu/Al焊接过程模拟代码lammps案例：Cu_Al界面原子扩散案例lammps案例：Cu基板液滴蒸发模拟案例代码lammps案例：Cu间隙原子形成能的模拟与计算方法lammps案例：Fe原子辐照轰击多层石墨烯模拟代码lammps案例：NaCl融化案例代码lammps案例：Ni_Graphene复合材料纳米压痕模拟lammps案例：Ni剪切过程中位错的滑移现象lammps案例：SiC拉伸下的裂纹扩展lammps案例：addforce方法实现链的拉伸lammps案例：fix indent命令实现纳米摩擦及摩擦力计算案例lammps案例：npt系综练手，H2压缩模拟lammps案例：分享一个金属晶界生成的lammps模拟代码lammps案例：分子自由落体运动模拟lammps案例：单晶Cu压缩案例讲解lammps案例：单晶Fe三向拉伸模拟lammps案例：反应力场reax/c设置方法及案例解析lammps案例：反应势reax模拟氢气燃烧过程lammps案例：团簇融化过程模拟案例学习lammps案例：圆锥形SiC纳米磨削单晶硅源代码lammps案例：堆垛层错能的计算lammps案例：小分子刚体设置几种方法lammps案例：小球随机碰撞模拟代码练习lammps案例：气体扩散现象模拟lammps案例：水分子在石墨烯狭缝中流动的案例代码lammps案例：流体绕过障碍物模拟代码讲解lammps案例：浇注过程的模拟lammps案例：液体平衡态rdf计算模拟练习lammps案例：热导率模拟案例讲解（NEMD方法）lammps案例：石墨烯热导率模拟代码（NEMD方法）lammps案例：石墨烯热导率模拟计算（EMD方法)lammps案例：石墨烯自动卷曲到Fe纳米线模拟源代码lammps案例：空位形成能的模拟与计算lammps案例：空位缺陷对石墨烯力学性能影响模拟代码lammps案例：聚乙烯/石墨烯侧面pull out模拟案例代码lammps案例：聚乙烯PE剪切过程分子动力学模拟lammps案例：聚乙烯和石墨烯界面pull out模拟代码lammps案例：聚乙烯拉伸lammps案例：聚合物链“走迷宫”模拟代码练习lammps案例：蒸发模拟如何动态的删除原子？lammps案例：金属液滴润湿模拟案例代码（Cu/SiC）lammps案例：铝和石墨烯复合物压缩变形in文件源代码lammps案例：高熵合金AlCoCrFeNi/金刚石摩擦案例代码lammps案例：高熵合金FeNiCrCoCu纳米压痕模拟代码lammps模拟Cu三点弯曲案例代码lammps模拟中tersoff势设置方法lammps模拟中刚体的设置方法lammps模拟中，控温失败的一个原因及解决方案lammps模拟技巧：高熵合金势函数设置三种方法lammps模拟时丢失原子怎么办？lammps模拟案例：Fe原子内聚能（Cohesive Energy）的计算模拟lammps模拟案例：TIP4P水球蒸发lammps模拟案例：晶体材料熔点的模拟lammps模拟案例：界面能的计算模拟lammps模拟模型变形严重，可能是结构有问题，介绍一个解决方法lammps模拟正交box转斜交(triclinic)两种简单方法介绍lammps混合势函数设置，常见的一个错误解决方案lammps编辑器VSCode不能自动识别命令，用这个方法解决lammps聚合物模拟，“bond missiong”键丢失的一个原因及解决技巧lammps自带命令create_atoms实现水分子建模lammps视频教程：Cu_H2O润湿模型建模方法lammps资料分享：Green–Kubo热导模拟代码详解msi2lmp不能用，mpi不能连接主机，解决办法看这里ovito作图系列（1）ovito作图系列（2）ovito作图系列（3）ovito作图系列（4）之党徽动画制作ovito作图系列（7）ovito常用功能介绍ovito闪退，试试这个解决方法！python学习之创建LAMMPS可读取的晶体结构模型python学习之创建LAMMPS可读取的随机原子模型relaxation时在NVE系综下，total energy 一直上升的问题variable命令两种不同的使用方式“v_和”&amp;”的区别”windows安装lammps必备：Microsoft .NET Framework 2.0 下载地址“atoms are time integrated more than once”警告，常见三种原因及解决办法“bond atoms missiong”键丢失的原因及解决办法（2）“ghost atoms”默认设置导致MDPD无法计算，添加一句命令轻松解决【DP系列教程-01】如何在5分钟之内setup一个DeePMD-kit训练【lammps第一讲】Cu的熔化模拟：保姆级教程一个OVITO的小技巧~一个与VMD匹配的计算密度分布的代码一个动画带你了解fix balance命令一个勉强算是通用的LAMMPS命令建模模板一个古老的构建FCC结构模型的代码一个古老的构建位错环的MD代码一个可以批量读取log文件信息的软件（修正重新发布）一个可以批量读取log文件信息的软件（适合LAMMPS新手）一个常见问题的解决方案一个常见问题的解决方案（补充）一个很好的Matplotlib实操总结一个很炫酷的MD视频一个很老的基于LJ势的MD代码一个想法——关于弄一个MD模拟的活动一个无厘头报错的解决方案一个更为全面的单位转换工具一个有趣的MD模拟一个有趣的建模软件一个构建多晶的小软件一个欢快的MD模拟（A molecule’s eye view of ice melting）一个简单的MD代码框架一个获取LJ势参数的脚本一个计算聚合能和晶格常数的简单示例一个讲解视频以及一个推荐视频一个重复文献时经常遇到的坑一个重复文献时经常遇到的坑（2）一个重复文献经常遇到的坑（3）一个镍微柱单轴压缩的in文件及注释一款直接帮你训练拟合出一个LAMMPS可以读取的eam/meam势文件的软件七夕：LAMMPS送你一颗小“心心”不敢稍忘，不能稍忘不规则界面建模技巧两种结构优化方式中国AI论文，爆了！二元合金势函数生成器什么？你的模拟体系又崩了？从python代码学MD（1）从python代码学MD（2）从复杂模型的构建小结LAMMPS基础命令的常用用法代码分享：Phonon-Vibration-Viewer代码学习：几个结构文件的转换脚本以论文案例讲解comb3势设置说明估算lammps模拟时间的一个小技巧体积模量计算使用Lammps对原子体系进行XRD分析使用OVITO进行原子类型随时间变化的统计使用Paraview后处理LAMMPS轨迹文件使用lammps自带命令复现论文复杂流体模型便利运行lammps的方法——在windows下鼠标右键直接运行in文件的办法值得收藏：一个包含多个碳纳米管生成器以及各种富勒烯模型的网址值得收藏：利用LAMMPS+Phonopy计算声子谱值得收藏：建模软件介绍(2)做润湿的可以看看这篇JPCL关于ATOMSK建模提示内存不足的问题原因及解决办法关于Deepmd软件的安装关于LAMMPS中的固定操作关于OVITO里面的渲染功能关于Tersoff力场文件编写-以新建FeSi.tersoff为例关于力场参数的选取关于力场文献查找关于弛豫关于查重关于检验力场参数的重要性关于牛顿层、恒温层以及固定层关于用LAMMPS计算自由能关于硕博论文的盲审关于结构关于表面能计算关于金属Cu熔化例子的两个建议再推荐一本书和一个up主冲击模拟演化过程几种水模型的相互作用参数刃位错原子模型及MD模拟分享一个lammps gcmc模拟CNT吸附水分子的案例代码分享一个lammps gcmc模拟案例教程分享一个lammps morse势参数查询网站分享一个计算液滴润湿接触角的python脚本分享一篇lammps模拟BaTiO₃的论文（附完整in文件源代码下载）分享一篇lammps模拟交联反应的论文以及案例in文件分享图片分子动力学后处理——TiNi原子结构的多种判别方法分子动力学模拟及其LAMMPS实现讲义，完全足够入门版分子动力学模拟及其LAMMPS实现讲义，足够入门版分子动力学模拟及其LAMMPS实现（1）分子动力学模拟及其LAMMPS实现（2）分子动力学模拟及其LAMMPS实现（3）分子动力学模拟及其LAMMPS实现（4）分析一个计算位错移动速度的python脚本创意时刻：lammps复杂图案建模方法初学必备：lammps串行和并行启动运算命令汇总，多线程设置方法初步了解LAMMPS的Makefile利用matlab快速将log文件信息保存在矩阵中势参数拟合初探单晶铜（OCC）纳米振动磨削模拟博士讲物理-原子过程（2）博士讲物理-费曼之理解世界原子应力的计算与表征原子间相互作用势函数理论模型与拟合方法简介又一本材料类新刊又一款帮助构建相互作用势的工具反应力场介绍及有机分子热分解的LAMMPS模拟反应力场验证第一步受控分子动力学（smd）向英雄致敬周末欣赏Simon Gravelle大神最新教程（含原始in文件）周末，听一首高熵合金神曲唯美的MD动画欣赏（双节快乐）国外博士论文推荐：实验+模拟（含多个LAMMPSin文件）国外学位论文推荐：压缩、拉伸以及剪切的MD模拟（含LAMMPS输入文件）在deepin15下的安装带gpu加速的LAMMPS(听说GPU加速很香)在lammps中进行楔形体压头建模在模拟时遇到一些“流氓”报错怎么办？坚守20年，终登Science基于VMD的一个计算接触角的小工具基础物理之费曼原子事实声子谱计算的in文件复现lammps论文模型：界面模型建模如何从曲线图中提取数据点？看看这个吧~如何使用VMD读取Lammps的data文件如何在模拟过程中统计区域内原子数目的变化如何把部分区域里面的某一类原子选出来如何搜索我们过去的文章如何理解velocity命令中的seed参数如何选CPU如何随机删除特定类型的原子孪晶多晶建模实践系列（小结）导读之润滑剂物性参数高通量分子动力学计算导读：Physics of Fluid-超疏水表面滑移特性小工具之Chain Alignment Parameter （链取向参数）小工具之ReaxFF产物个数随时间的变化统计小工具之ReaxFF成键断键可视化小工具之ReaxFF模拟分子种类随时间变化提取-修改版小工具之in-plane静态结构因子的MATLAB程序小工具之金属材料生成一维随机粗糙度小工具之静态接触角测量的MATLAB程序平均力势（PMF)简介广义堆垛层错能曲线绘制建模专题（小结）建模小技巧（2）建模小技巧（3）根据cif文件在in文件中写建模命令建模小技巧（一）建模软件介绍(1)强烈推荐：施加载荷下的lammps摩擦模拟案例代码下载快、准！思路（1）：从读文献到写in文件（新手必读）思路（2）：从读文献到写in文件（新手必读）我们组的第一篇Matter：晶界和C纳米管联合作用提高核材料性能手册翻译之LAMMPS的in文件语法规则手册翻译之fix bond/create（用于模拟聚合物交联）手册翻译之fix bond/react打破经验势的束缚：机器学习势（AENET）找力场对应的文献很难？看看这里~据说很多高熵合金的势文件是这么来的~推荐一本书以及一个up主~推荐一款帮助拟合MEAM势参数的软件推荐一款特好用的lammps编辑器，代码自动补全，高手必备推荐一篇做切削的博士论文（含in文件）推荐：pdb2data模型数据转换工具—— Matlab + packmol的小分子体系建模方法推荐：不同金属钨势函数的测评改源码之耗散粒子动力学滑移边界条件控制文献推荐：势参数拟合的挑战和策略文献精读：Graphene拔出的分子动力学模拟-Graphene几何形状的影响新年第一个MD视频新手常见问题集合新手常见问题集合(新)新手荐读：MS导出的.car/.mdf如何转到lammps data文件新手荐读：使用tersoff势计算硅碳热导率新材料理论设计软件—洛阳师范刘忠利课题组无法理解物理定律？看看这个无需后处理，karl大佬教你缺陷模拟分析一步到位旧手机怎么处理？当然是跑LAMMPS啊昨天视频的in文件晚安晶格常数计算：以单晶Al为例最新合金势的测试结果最新版Windows并行版lammps安装教程最新版deepmd（包含支持多个包的预编译的LAMMPS）最新的三元合金势函数最新的合金势函数最新谱分解代码最是一年中秋美，花前月下人相对有机小分子/大分子(原子数小于200)的OPLS-AA力场参数获取方法（1）有机小分子/大分子(原子数小于200)的OPLS-AA力场参数获取方法（2）有机小分子/大分子(原子数小于200)的OPLS-AA力场参数获取方法（3）有机小分子/大分子(原子数小于200)的OPLS-AA力场参数获取方法（4）有趣的MD模拟（二）本公众号关注人数今天正式破万，特此记录下，感谢各位老师同学的关注和支持了[抱拳][抱拳]根据金属Fe, Ni, Pb以及Cr实验熔点拟合的L-J势参数案例分享：水分子剥离多层石墨烯片案例代码下载樊哲勇老师在线讲CUDA编程樊哲勇老师热导率教程的下载链接模拟吸附原子表面扩散的in文件正6边形多晶试样建模(LAMMPS版)正6边形多晶试样建模(atomsk版)氢键的判定条件及使用VMD简单统计体系中的氢键数量水分子模型汇总网站（包含in文件，力场文件等）水化硅酸钙的LAMMPS模拟水在Cu表面润湿过程lammps模拟案例代码水滴润湿的LAMMPS模拟没有输出，再好的模拟也没用：dump命令4种用法注意：lammps最新版本更换运行命令注释版in文件：Intrinsic-Stacking-Fault-Energy注释版in文件：polyurethane_aluminum_interface注释版模拟吸附原子表面扩散的in文件注释版金刚石冲击石墨烯的in文件流体润滑的耗散粒子动力学模拟润湿系列教程1-所需软件及规划润湿系列教程2-使用Packmol建立液滴模型+香港理工大学留学机会润湿系列教程3-使用MS建立基底+基底液滴合并润湿系列教程4-LAMMPS的data文件导出与in文件编写润湿系列教程5-润湿接触角测量深度好文：怎么用lammps输出原子速度计算声子谱源码学习之LAMMPS的一个时间步是如何工作的热导率LAMMPS计算和各种后处理技巧王延颋老师的LAMMPS教程PPT理论+实验=？用自己的方式向老师表达祝福，附完整建模代码田老师势能精讲第三篇上线了界面版msi2lmp转换工具（新手建模必看）石墨烯海水淡化lammps模拟建模方法端午快乐（另附注释版3d-Crack模拟）简单上手的金刚石孪晶建模教程简单模拟，深入分析算力不足！怎么破？告诉你个小技巧粗粒化离子液体超级电容器模型构建纳微界面亲和性对传递反应过程的影响机制研究纳米切削过程的实现及其简要分析流程纳米压痕模拟中输出Force-depth图纳米压痕详细教程经典MD模拟经典MD模拟（盐溶于水）编制石墨烯的建模耗散粒子动力学聊一聊 LAMMPS in 文件的书写（新手必读）聚合物建模软件Packmol的使用简介视频教程：OVITO制作原子运动轨迹计算机模拟：生化环材研究生的自我救赎之道（自学模拟经验谈）让我们用MDer的方式给党庆生记录一次对模型实施“外科手术”，实现“美颜”的过程试着一张图理解LAMMPS中的press赶紧保存收藏：计算声子参与率的代码赶紧收藏：4个经典LAMMPS例子赶紧收藏：SCIENCE子刊教你用LAMMPS算自由能赶紧收藏：Simon Gravelle 大神最新教程赶紧收藏：V-CoCrFeMnNi六元合金势函数赶紧收藏：github上LAMMPS案例收集赶紧收藏：一个包含众多LAMMPS实例的网站赶紧收藏：一个包含大量in文件和处理脚本的网站赶紧收藏：一个包含大量in文件的github赶紧收藏：一个快速查询原子摩尔质量的网站赶紧收藏：一个给出了每篇文章后面的in文件和python代码的课题组网站赶紧收藏：一个获取LJ势参数的网站赶紧收藏：两个冲击实例赶紧收藏：又一个包含in文件的教程网站赶紧收藏：又一个包含众多LAMMPS实例的网站赶紧收藏：又一个含有众多LAMMPS案例的网页赶紧收藏：最新L-J势参数以及最全的原始计算文件赶紧收藏：最新合金势函数赶紧收藏：最新的高熵合金势（LAMMPS可以直接用）超疏水表面气液界面滑移LAMMPS模拟交流视频超高分子量聚乙烯LAMMPS的data文件转载：在lammps中生成纤维素拓扑结构以及charmm力场参数还在实验室的MDer们怎么过中秋？进军机器学习的准备工作之学会VASP送论文之电润湿长距离液体驱动的多体耗散粒子动力学重复文献需要注意的地方之力场参数的确定金属顶刊：高熵合金的MD模拟铝/石墨烯复合物结晶过程lammps模拟铝粉锻造分子动力学模拟随便说点（后附BCC结构建模代码）随即替换法生成大量高熵合金模型然后找寻其中能量最低的构型非晶金属模型建模：Ovito方法香港中文大学许建斌教授博士招生香港理工大学留学机会高熵合金中的mcsqs建模流程（重发一次）赶紧收藏：一个包含众多LAMMPS实例的网站","link":"/2022/07/22/%E7%BD%91%E4%B8%8A%E5%85%AC%E4%BC%97%E5%8F%B7%E6%89%80%E6%9C%89%E7%9A%84LAMMPS%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/"},{"title":"如何理解Kirchhoff弹性杆？","text":"不可拉伸弹性杆为什么可解？ 前言 一直想写一篇文章来解释弹性杆的原理但是迫于能力问题，迟迟没有下笔。弹性杆在生活中有着广泛的应用，下面简单列举几个。 为什么有的植物藤曼是螺旋状的，有的是平面曲线？ 葡萄的藤曼是如何爬上支架的？蛇是如何运动的？（包括平面上的运动，曲面上的运动：蛇爬树） 如何更可靠的铺设海底电缆？ 捏住绳子的两端反向揉搓，为什么绳子中间会变成麻花形状？ 悬链线的形状，弹性悬链线，考虑弯曲能的弹性悬链线形状的形状？ DNA结构是如何由力学主导的？ 莫比乌斯带中的应力分布?（Mahadevan L 1993） 竹笋是如何生长成变圆锥状的？ 弹性杆的应用有很多，这里就不一一列举了。事实上，历史上很多著名的问题都是弹性杆的特例，如悬链线问题、弹性悬链线问题、扭转失稳（twist bulking），绳子下落问题等。此外，很多著名的科学家都对弹性杆的研究做出了贡献，如Euler; Kirchhoff; Bernoulli; Bonn等。此外，弹性杆需要用到古典微分几何的知识，应当意识到弹性杆不仅仅与曲线论密切相关，更与流形上的弹性结构有着密切关系。这并不是脱离实际的，线状弹性问题约束在一个曲面（二维流形）上运动时，流形上的弹性理论也许能发挥重要作用。（蛇爬树就是很现实的一个例子。） 上世纪末，David Singer &amp; Langer 曾经研究了黎曼流形上的Euler弹性杆，这仅仅是考虑了弯曲能的静态解，这方面还有很多路要走。 这里主要是想说明两个问题： 1 弹性杆的运动与哪些物理量有关， 弹性杆的运动为什么是可解的？ 2 弹性杆研究的困难在哪里？ 需要提前说明的是，妄想掌握了弹性杆的框架之后就能通过PDE数值方法去求解任意弹性杆的运动是不现实的。即使不需要任何理论，仅仅凭我们的生活常识就能看到，一些绳子扭结之后曲率的变化是非常大的，这往往会导致数值算法的失效。其次，即使对于ODES的两点边界条件，初值的猜测是困难的，很多时候需要结合物理场景。matlab自带的打靶法求解函数bvp4c, bvp5c的使用被描述为”更多的是一种艺术而不是技术”，可以想象对于一些复杂边界条件弹性杆方程求解更是难上加难了。近年来，离散弹性杆(Discrete Elasic Rod)的产生使得可以通过使用计算机仿真很多弹性杆力学行为。本质上讲，离散弹性杆(DER)的研究更多的是为了解决数值困难而不是物理理论。 概览：与那些物理量有关？无论是板壳理论还是弹性杆，都是弹性力学衍生出的简化理论，这种简化是由几何对称性得到的。如同连续介质力学中一样，问题求解离不开三个部分：几何方程，物理方程，平衡方程。 \\{\\boldsymbol{u}, \\boldsymbol{v}, \\boldsymbol{\\omega}, \\boldsymbol{k}, \\mathbf{M}, \\mathbf{Q}, \\boldsymbol{\\theta}\\}上述七个量共有21个分量，全部是关于杆弧长坐标以及时间的函数。 物理意义如下： 物理量 物理意义 位移 速度 时间Daboux矢量 空间Daboux矢量 内力矩 内力 欧拉角（四元数） 弹性杆解的七个方程： 1 Kirchoff 平衡方程 2 2 时空几何变换方程（Rotate Tensor与（欧拉角/四元数）的关系） 2 3 速度及切矢量物理方程 （速度与位移的关系 位移与切矢量关系Frenet方程） 2 4 本构方程 1 每个方程有三个分量一共 21 个分量形式的方程，除此之外，还有Frenet方程，把位移，内力，内力矩展开为局部坐标并求导时会用到这个几何关系。 方程 物理意义 受力平衡 力矩平衡 速度位移关系 切矢量位移关系 空间旋转矢量与欧拉角 时间旋转矢量与欧拉角 广义胡克定律 弹性的来源：本构关系在我小时候，家里开着一间杂货铺，售卖各种型号的金属丝。有一些个有意思的现象：把细的铁丝折弯之后，铁丝很容易恢复到原来的形状，粗铁丝却不行；同样粗的金属丝，铁丝折弯后能很快恢复到原来的形状，铅丝却不行。如果熟悉Euler梁，应该可以理解这个现象，抗弯刚度：, 分别为截面惯性矩和杨氏模量。对于圆截面：。可以看出反应铁丝的“粗细”， 反映了铁丝的种类。两个量的组合反映了铁丝的弯曲变形与外力的关系。对于同一材料，弹性极限确定，抗弯刚度越大越容易达到弹性极限，进入塑性阶段，这解释了为什么粗的铁丝弯曲后不容易恢复。伯努利假设：通过平截面假设得到了弯曲的本构关系：。 \\boldsymbol{M}=M_{i} \\boldsymbol{d}_{i} \\\\ M_{1}=G J m M_{2}=E I_{2} m_{1} M_{3}=E I_{3} m_{2}几何相容关系四元数，欧拉角及其与 Frame Tensor 的关系 首先，给出Frame Tensor 的一些性质以及与Rotate Tensor, Daboux Vector之间的关系。这里提前说明一点，用作为变量只是为了方便起见，并不具有物理意义，这里并没有说局部标架是通过时间对初始标架进行变换的还是通过弧长参数对初始标架进行变换得到。 如何从张量的观点看待曲线论？ \\left\\{\\begin{array}{l} \\Omega+\\Gamma=0 \\\\ \\Gamma=\\epsilon \\cdot \\omega \\\\ \\omega=\\frac{1}{2} \\epsilon: \\Gamma \\\\ \\frac{1}{2} \\epsilon: \\Omega+\\omega=0 \\\\ \\epsilon \\cdot \\omega+\\Omega=0 \\end{array}\\right. \\Gamma_{i}^{j}=\\frac{d R_{i}^{m}}{d s} R_{j}^{m}+R_{i}^{n} \\Gamma_{0 n}^{m} R_{j}^{m}各种坐标系的特征量如下： Bishop Frame Frenet Frame Material Frame General Frame Frame Tensor Rotate Tensor Daboux Tensor 换句话说，之所以产生Material Frame, Bishop Frame的原因是：弹性杆无论是绕着还是转动都表现为弯曲，而绕着转动则表现为扭转，这表明了曲线特有的对称性（更说明了几何对称性带来的简化在连续介质力学理论应用中的重要性）。这种对称性决定了无论空间标架怎么选取，第一个随体标架基选择切矢量总是一种比较好的方式，(3)式表明各种Frame的Frame Tensor都可以由General Frame绕着轴旋转得到，这是Bishop Frame, Material Frame的参数命名关于对称的原因。 Whittaker, E. T.给出了固有坐标到随体坐标变换中四元数与Frenet张量的关系。 \\begin{array}{c} \\left(\\begin{array}{l} \\boldsymbol{d}_{1} \\\\ \\boldsymbol{d}_{2} \\\\ \\boldsymbol{d}_{3} \\end{array}\\right)=\\mathbf{R}\\left(\\begin{array}{l} \\boldsymbol{e}_{1} \\\\ \\boldsymbol{e}_{2} \\\\ \\boldsymbol{e}_{3} \\end{array}\\right)\\left(\\begin{array}{l} \\boldsymbol{d}_{1 s} \\\\ \\boldsymbol{d}_{2 s} \\\\ \\boldsymbol{d}_{3 s} \\end{array}\\right)=\\boldsymbol{\\Gamma}\\left(\\begin{array}{l} \\boldsymbol{d}_{1} \\\\ \\boldsymbol{d}_{2} \\\\ \\boldsymbol{d}_{3} \\end{array}\\right) \\\\ \\left(\\begin{array}{c} \\boldsymbol{d}_{1 s} \\\\ \\boldsymbol{d}_{2 s} \\\\ \\boldsymbol{d}_{3 s} \\end{array}\\right)=\\mathbf{R}_{s}\\left(\\begin{array}{l} \\boldsymbol{e}_{1} \\\\ \\boldsymbol{e}_{2} \\\\ \\boldsymbol{e}_{3} \\end{array}\\right)=\\boldsymbol{\\Gamma}\\left(\\begin{array}{l} \\boldsymbol{d}_{1} \\\\ \\boldsymbol{d}_{2} \\\\ \\boldsymbol{d}_{3} \\end{array}\\right)=\\boldsymbol{\\Gamma} \\mathbf{R}\\left(\\begin{array}{l} \\boldsymbol{e}_{1} \\\\ \\boldsymbol{e}_{2} \\\\ \\boldsymbol{e}_{3} \\end{array}\\right) \\end{array} \\boldsymbol{\\Gamma}=\\mathbf{R}_{s} \\mathbf{R}^{\\mathbf{T}}当转动矩阵表示为四元数形式时，得到Frame张量与四元数的关系，表示为欧拉角形式时得到Frame张量与欧拉角的关系。其实两者无所谓，Frame Tensor的三个张量看似得到了三个方程，其实对于四元数表示转动会外加一个隐含的约束：，这使得对于无论是三个参数由欧拉角表示的转动，还是四个参数由四元数表示的转动，Frame Tensor与转动参数之间的关系都是可解的。这是解算弹性杆运动中的一个重要的几何关系，因为一般死载 (dead load) 载都是表示在固有坐标中的，而弹性杆运动方程是在局部坐标中建立的。一些关于四元数和欧拉角的计算函数。(5)式表明，以下三个矩阵是等价的： Frame Tensor (Material) (Euler form(3,2,3)) (Quaternion form) 四元数、欧拉角与Frame Tensor的关系为： 时间 Davoux Vector 与空间 Daboux Vector 的关系弹性杆上点的运动涉及两个自变量，时间与空间，自然需要两套Frame Tensor来把局部标价对两自变量的偏导数与局部标价联系起来。 一般的，考虑弹性杆方程中的物理量 ，并要求对于时间，空间的二阶偏导数是可交换的。（为什么这么要求？可能是实际中要求物理量是 的，可以类比应力波中的位移。利用时空二阶偏导可交换的性质，可以得到速度梯度等于应变率这一结论。）不妨考虑恒定的情况，由(5)式得到： 利用Jacobi恒等式 得到: 是任意的，得到恒等式： 利用Daboux Vectror与Frame Tensor的关系 可以得到: 分别为 对应的Frame Tensor。 这是一个冗余方程，因为： 由Frenet Tensor与转动张量的关系给出：考虑转动张量的性质：，对上式求导得：，化简得到：由(14)式得： 速度与位移利用局部标架基，可以把弹性杆的速度和位移表示为如下形式： 物理平衡Kirchhoff Über das Gleichgewicht und die Bewegung einer elastischen Scheibe 力平衡 弹性杆微元受力图 前面已经提到，无剪弹性杆本构关系的产生来自平截面假设，这里又一次用到了（无剪）条件。弹性杆运动过程中，截面与轴线始终是垂直的，因此轴线上点的运动可以代表弹性杆微元的运动。注意，轴线是截面质心随弧长参数变化所演化出的一条曲线。 对弹性杆微元应用质心运动定理，得到力平衡方程（动量）： 矩平衡矩平衡方程的推导比较讲究，因为我们是站在固有坐标系中看待弹性杆运动的，因此可以把弹性杆微元的角动量分解为两个部分：相对质心的角动量＋质心角动量，即： 。首先来看, 相当于轴线中心点处质点相对于原点的角动量，直接可以写为：。 下面考虑微元截面上物质点相对质心的角动量： 对微元段应用质心角动量定理，得到矩平衡方程（角动量）： 角动量对时间微分，应用叉乘的微分法则并注意到含 的奇次项在截面上积分为零，得到： 分别表示对轴的惯性矩， 表示单位线元的角动量。结合(16) (17)式，并利用(13)式进行化简，得到矩平衡方程：截面惯性矩： 黎曼流形上的弹性杆受力方法推导弹性杆方程的好处是可以清晰的得到各个物理量所导致弹性杆控制方程的数学结构。如果从能量的角度出发，可以粗略的求解出Euler弹性线满足的方程（不考虑Torsion的Kirchhoff弹性杆）。欧氏空间中的弹性线方程在弹性线问题与数值求解中已进行说明，管中窥豹从这个最简单的Euler弹性线方程求解中都可以看出数值求解的困难（Euler法求解精度很低，需要用预报矫正算法）。 曲面上曲线的曲率可以分解为法曲率和测地曲率，法曲率为曲线上一点作法截面与曲面相交得到截线的曲率，测地曲率表示曲线相对测地线的偏离程度。平面上的弹性线约束为曲率（测地曲率，此时法曲率为零）平方取极小值，如果考虑曲面上的弹性线被测地曲率平方取极小值这个条件所约束（一些各向异性弹性杆可能会出现这种情况。），得到曲面上的Euler弹性线方程。 怎么来看待这个东西？一般来讲，经典力学考虑三维平直时空中物体的动力学，三位平直时空是确定存在的。曲面上弹性线相当于考虑二维流形上的一维细线的运动，二维流形无论是否平直都可以嵌入到三维平直时空中。因此，曲面上的弹性线是具有应用价值的。 首先证明无挠Riemann流形(Levi-Civita联络具有对称性)的一个性质(为方向导数的推广，称为协变导数。在古典微分几何曲面论中可以理解为不包含法向分量的向量导数。具体见《黎曼几何初步》伍鸿熙)：Riemann流形上曲线的Frenet方程为： 考虑对新的参数进行变分以及速度矢量:对，偏导数可交换，得到:由上式得：曲率对的变分为： 考虑能量泛函： 变分得到：其中利用了Riemann曲率张量以及性质。 其中：当时，上式为Riemann Manifold上弹性线满足的方程。 讨论：对于常曲率流形，Riemann曲率退化到Gauss曲率 结合流形上的Frenet公式得到：常曲率流形(二维情况就是球面 伪球面 平面)上的弹性线方程为：可以看出上式与欧氏空间中的弹性线方程相比较多了流形曲率的贡献项。 对与平面来说，Riemann流形上的弹性线方程退化到欧氏空间中的弹性线方程。 参考文献 Lectures on Elastic Curves and Rods 黎曼几何初步 Mahadevan L.and Keller Joseph B. 1996 Coiling of flexible ropesProc. R. Soc. Lond. A.4521679–1694 Mahadevan L. and Keller Joseph Bishop 1993The shape of a Möbius bandProc. R. Soc. Lond. A440149–162 Dynamics of Rod Statics of Rods","link":"/2023/02/08/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3Kirchhoff%E5%BC%B9%E6%80%A7%E6%9D%86%EF%BC%9F/"},{"title":"一些常用的python脚本","text":"data2molecule data2POSCAR DFT_deform data2molecule123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116import pandas as pdimport numpy as npimport osimport timemodelname=\"8_lmp\"csvname=modelname+\".csv\"f = pd.read_csv(modelname+\".data\", header=None)str = [' atoms', ' bonds', ' angles', ' dihedrals', ' impropers', ' atom types', ' bond types', ' angle types', ' dihedral types', ' improper types', 'xlo xhi', 'ylo yhi', 'zlo zhi', 'Masses', 'Atoms', 'Velocities', 'Bonds', 'Angles', 'Dihedrals', 'Impropers']N = len(str)p = ' Impropers'row_id = np.zeros(N)for i in range(N): q = f[f[0].str.contains(str[i])].index.tolist() if len(q) == 1: row_id[i] = q[0]row_id.tolist()## 筛选特定行 并 提取信息id_bo = int(row_id[16])id_an = int(row_id[17])id_di = int(row_id[18])id_im = int(row_id[19])## 定义特定拓扑结构字符串并新建mol文件inistr = [\"\\t\", \"Coords\", \"\\t\", \"Types\", \"\\t\", \"Charges\", \"\\t\", \"Bonds\", \"\\t\", \"Angles\", \"\\t\", \"Dihedrals\", \"\\t\", \"Impropers\", \"\\t\"]strinsert = pd.DataFrame(inistr)mol = open(modelname+\".csv\", 'w')info = [\"#molecule file generated by python --JiahaoLi \" + time.strftime('%Y:%m:%d %H:%M:%S', time.localtime(int(time.time()))), \"\\t\"];pd.DataFrame([info]).to_csv(csvname, mode='a', index=None, header=False)for i in range(5): f.iloc[int(row_id[i])].to_csv(csvname, mode='a', index=None, header=False)xyz = f.iloc[int(row_id[14]) + 1:int(row_id[15])]p = xyz[0].str.split(' ', expand=True)# 输出头文件strinsert[0:3].to_csv(csvname, mode='a', index=None, header=False)tp = pd.merge(p.iloc[:, 0], p.iloc[:, 4:7], left_index=True, right_index=True)tp.to_csv(csvname, mode='a', index=None, header=False, sep=' ')strinsert[2:5].to_csv(csvname, mode='a', index=None, header=False)tp = pd.merge(p.iloc[:, 0], p.iloc[:, 2], left_index=True, right_index=True)tp.to_csv(csvname, mode='a', index=None, header=False, sep=' ')strinsert[4:7].to_csv(csvname, mode='a', index=None, header=False)tp = pd.merge(p.iloc[:, 0], p.iloc[:, 3], left_index=True, right_index=True)tp.to_csv(csvname, mode='a', index=None, header=False, sep=' ')## 输出拓扑信息数目# mol.close()if id_bo == 0: mol.close()elif (id_bo != 0) &amp; (id_an != 0) &amp; (id_di != 0) &amp; (id_im != 0): strinsert[6:9].to_csv(csvname, mode='a', header=False, index=None) p = f.iloc[id_bo + 1:id_an] p.to_csv(csvname, mode='a', index=None, header=False) strinsert[8:11].to_csv(csvname, mode='a', header=False, index=None) f.iloc[id_an + 1:id_di].to_csv(csvname, mode='a', index=None, header=False) strinsert[10:13].to_csv(csvname, mode='a', header=False, index=None) f.iloc[id_di + 1:id_im].to_csv(csvname, mode='a', index=None, header=False) strinsert[12::].to_csv(csvname, mode='a', header=False, index=None) f.iloc[id_im + 1::].to_csv(csvname, mode='a', index=None, header=False)elif (id_bo != 0) &amp; (id_an != 0) &amp; (id_di != 0) &amp; (id_im == 0): strinsert[6:9].to_csv(csvname, mode='a', header=False, index=None) f.iloc[id_bo + 1:id_an].to_csv(csvname, mode='a', index=None, header=False) strinsert[8:11].to_csv(csvname, mode='a', header=False, index=None) f.iloc[id_an + 1:id_di].to_csv(csvname, mode='a', index=None, header=False) strinsert[10:13].to_csv(csvname, mode='a', header=False, index=None) f.iloc[id_di + 1::].to_csv(csvname, mode='a', index=None, header=False)elif (id_bo != 0) &amp; (id_an != 0) &amp; (id_di == 0) &amp; (id_im != 0): strinsert[6:9].to_csv(csvname, mode='a', header=False, index=None) f.iloc[id_bo + 1:id_an].to_csv(csvname, mode='a', index=None, header=False) strinsert[8:11].to_csv(csvname, mode='a', header=False, index=None) f.iloc[id_an + 1:id_im].to_csv(csvname, mode='a', index=None, header=False) strinsert[12::].to_csv(csvname, mode='a', header=False, index=None) f.iloc[id_im + 1::].to_csv(csvname, mode='a', index=None, header=False)elif (id_bo != 0) &amp; (id_an != 0) &amp; (id_di == 0) &amp; (id_im == 0): strinsert[6:9].to_csv(csvname, mode='a', header=False, index=None) f.iloc[id_bo + 1:id_an].to_csv(csvname, mode='a', index=None, header=False) strinsert[8:11].to_csv(csvname, mode='a', header=False, index=None) f.iloc[id_an + 1::].to_csv(csvname, mode='a', index=None, header=False)elif (id_bo != 0) &amp; (id_an == 0) &amp; (id_di != 0) &amp; (id_im != 0): strinsert[6:9].to_csv(csvname, mode='a', header=False, index=None) f.iloc[id_bo + 1:id_di].to_csv(csvname, mode='a', index=None, header=False) strinsert[10:13].to_csv(csvname, mode='a', header=False, index=None) f.iloc[id_di + 1:id_im].to_csv(csvname, mode='a', index=None, header=False) strinsert[12::].to_csv(csvname, mode='a', header=False, index=None) f.iloc[id_im + 1::].to_csv(csvname, mode='a', index=None, header=False)elif (id_bo != 0) &amp; (id_an == 0) &amp; (id_di != 0) &amp; (id_im == 0): strinsert[6:9].to_csv(csvname, mode='a', header=False, index=None) f.iloc[id_bo + 1:id_di].to_csv(csvname, mode='a', header=False, index=None) strinsert[10:13].to_csv(csvname, mode='a', header=False, index=None) f.iloc[id_di + 1::].to_csv(csvname, mode='a', index=None, header=False)elif (id_bo != 0) &amp; (id_an == 0) &amp; (id_di == 0) &amp; (id_im != 0): strinsert[6:9].to_csv(csvname, mode='a', header=False, index=None) f.iloc[id_bo + 1:id_im].to_csv(csvname, mode='a', index=None, header=False) strinsert[12::].to_csv(csvname, mode='a', header=False, index=None) f.iloc[id_im + 1::].to_csv(csvname, mode='a', index=None, header=False)elif (id_bo != 0) &amp; (id_an == 0) &amp; (id_di == 0) &amp; (id_im == 0): strinsert[6:9].to_csv(csvname, mode='a', header=False, index=None) f.iloc[id_bo + 1::].to_csv(csvname, mode='a', index=None, header=False)mol.close()os.rename(modelname+\".csv\", modelname+\".mol\")# m=f.iloc[id_bo:id_an] data2POSCAR（其实没什么必要,ovito可以直接转换。。。。。。） 123456789101112131415161718192021222324252627282930313233import numpy as npimport pandas as pdimport osf=pd.read_table(\"C7H7N\",header=None,delim_whitespace=True).fillna(' ')xx=f.index[f[2].str.contains('xlo')].tolist()xx=xx[0]yy=f.index[f[2].str.contains('ylo')].tolist()yy=yy[0]zz=f.index[f[2].str.contains('zlo')].tolist()zz=zz[0]xlength=float(f[1][xx])-float(f[0][xx])ylength=float(f[1][yy])-float(f[0][yy])zlength=float(f[1][zz])-float(f[0][zz])a=f.index[f[0].str.contains('Masses')].tolist()a=a[0]b=f.index[f[0].str.contains('Atoms')].tolist()b=b[0]ele=f[3][a+1:b]c_type=f[2].iloc[b+1::].tolist()ele_name=\"\"ele_num=\"\"for i in range(len(ele)): ele_name=ele_name+f[3].iloc[a+i+1]+\" \" ele_num=ele_num+str(c_type.count(f[0].iloc[a+i+1]))+\" \"txyz=f.loc[b+1::,[2,4,5,6]]txyz.sort_values(2,inplace=True)xyz=txyz.loc[b+1::,[4,5,6]]mol=open(\"POSCAR\",'a')mol.write(\"POSCAR generated by python ##Jiahao \\n 1 \\n\")mol.write(str(xlength)+\" \"+\"0.0 0.0\\n\"+\"0.0 \"+str(ylength)+\" 0.0\\n\"+\"0.0 0.0 \"+str(zlength)+\"\\n\")mol.write(ele_name+\"\\n\"+ele_num+\"\\n\"+\"Castein \\n\")mol.close()xyz.to_csv('POSCAR',index=False,header=0,mode='a',sep=' ') DFT计算材料变形123456789101112131415#!/bin/shrm -r POSCARcp CONTCAR CONTCAR.$@cp OSZICAR OSZICAR.$@mv CONTCAR POSCAR.$@awk 'BEGIN{my_a = 0.01; my_b = 0}{ if ((NR&lt;=33&amp;&amp;NR&gt;=10)||( NR&lt;=102&amp;&amp;NR&gt;=66 )||(NR&lt;=110&amp;&amp;NR&gt;=106)||(NR&lt;=126&amp;&amp;NR&gt;=112)) { my_b = $2 + my_a; if (my_b &gt; 1) my_b = my_b - 1; printf(\"%.7f %.7f %.7f %s %s %s\\n\",$1, my_b,$3,$4,$5,$6); } else print $0; }' POSCAR.$@&gt;POSCAR","link":"/2023/02/23/%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84python%E8%84%9A%E6%9C%AC/"},{"title":"Kirchhoff弹性杆理论的简化形式","text":"Kirchhoff弹性杆如何退化到一些经典理论？均假设为恒定圆截面弹性杆 静态弹性杆 上式化简为：分两种情况讨论： ① 转动采用欧拉角形式表示（3-2-3转动） 转动矩阵为：Frenet矩阵为：(2) (3) (4)结合表达为分量形式可以得到：共有12组方程，12个变量()。上述方程组是封闭的。 ② 转动采用四元数形式表示 转动矩阵为：Frenet矩阵为：加上约束： (2) (6) (7) (8)结合表达为分量形式可以得到：转动表达形式选取影响的只是(5)式，在存在载荷时会体现出与欧拉角求解的差异，外部载荷为零时，由于是局部标架与整体标架是解耦的。 简化讨论若外载荷为0，欧拉角从上述方程中解耦出来。得到：化简为： 即使对于无外载荷的Kirchhoff弹性杆，求得的控制方程已经足够复杂。现在考虑选取Frenet坐标系，即令，上式化简为：定义，为泊松比。得到控制方程：通过(9)积分得到：求出含扭转无载静态弹性杆的控制方程为：可以看出，如果不考虑扭转能，令，(11)退化到弹性线问题与数值求解中通过能量泛函求出的Euler’s Elastica Rod方程。 稳态弹性杆（沿绳子运动）局部标架二阶导表达式为：弹性杆方程： 二维理论二维静态理论从静态理论的代码开始简化：简化条件：矢量方程化简为：在这里分两种情况进行讨论：① 小角度情况： ，此时标架与固定坐标系重合，(6)式化简为：对于不可拉伸梁结构，轴力为常数。对于悬臂梁右端轴力为零，因此 。由(8)式得到： 对于恒定弯矩载荷作用梁，上式退化为经典的欧拉梁公式：② 外力载荷为0的情况：此时 q_x(s)=0,q_y(s)=0 (6)式化简为：(10)式化简为：如果外力矩载荷为零， 。得到：，展开后即为Euler Elastica方程(弹性线问题与数值求解中通过能量方法已经得到)： 二维稳态理论二维稳态理论可简化为：简化条件：矢量方程简化为：上式化简为：","link":"/2023/02/28/Kirchhoff%E5%BC%B9%E6%80%A7%E6%9D%86%E7%90%86%E8%AE%BA%E7%9A%84%E7%AE%80%E5%8C%96%E5%BD%A2%E5%BC%8F/"},{"title":"如何旋转周期性模型？","text":"如何旋转周期性模型？几何关系 假设左图是材料的最小周期型单元，经过旋转后得到右图的模型。要想满足周期性边界条件，假设方向上有个周期，方向上有个周期。需满足如下关系式： l_x=md_y \\sin\\theta \\\\ l_y=md_y \\cos\\theta \\\\ nd_x=\\frac{l_x}{\\cos\\theta}得到： 同时需要满足体积守恒$d_xd_ymn=l_xl_y$ 最终解得： \\sin\\theta \\cos\\theta=\\tan\\theta只有时成立，也就是说除了转动90度的倍数，不存在旋转后仍未周期性的体系，晶格常数必然发生失配。 既然晶格常数无法满足旋转的要求，要想让容差率达到最小，应该如何做？ 数值近似解 假设初始晶格比，蓝线为旋转后的体积容差，黄线为旋转后的横向键长容差，红线为总容差。 我们修改(1)式，引入容差来描述体积的变化率，来描述横向键长的变化（在0附近，在1附近）： l_x=md_y \\sin\\theta \\\\ l_y=md_y \\cos\\theta \\\\ nd_x*\\gamma=\\frac{l_x}{\\cos\\theta}\\\\ nmd_xd_y*(1+\\Delta\\varphi)=l_xl_y定义误差函数，最终求得误差以及晶格比与角度的变化。 etol=\\sqrt{(\\lambda tol)^2+(\\Delta \\varphi tol)^2}=\\sqrt{\\left(\\lambda p \\tan \\left( \\theta\\right)-1\\right)^2+\\left(\\lambda p \\sin ^2\\left( \\theta\\right) \\tan \\left( \\theta\\right)\\right)^2}误差函数的极小值可以解析求解为： etol_{,p}=0\\\\ p=\\frac{\\cot\\theta}{\\lambda(1+\\sin^4\\theta)}\\\\ \\lambda tol=\\frac{1}{1+\\sin^4\\theta}-1\\\\ e\\Delta\\varphi=\\frac{\\sin^2\\theta}{1+\\sin^4\\theta}\\\\ etol=\\frac{\\sin^2\\theta}{\\sqrt{1+\\sin^4\\theta}}旋转前后的最佳晶格比为： 可以看出，要想将容差控制在大约10%以内，取向角被限制在0~20度。 范例S2层粗粒化模型元胞满足，对于不同的取向角可以取不同的值。 n m p 10 21 2.1248 10 87.5187 496.343 1 1 1.0164 20 8.20848 22.5526 16 10 0.611312 30 120 207.846 21 10 0.483251 35 137.658 196.596 旋转周期性模型需要用倾斜的盒子！","link":"/2023/08/20/%E5%A6%82%E4%BD%95%E6%97%8B%E8%BD%AC%E5%91%A8%E6%9C%9F%E6%80%A7%E6%A8%A1%E5%9E%8B%EF%BC%9F/"}],"tags":[{"name":"音乐","slug":"音乐","link":"/tags/%E9%9F%B3%E4%B9%90/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"DFT","slug":"DFT","link":"/tags/DFT/"},{"name":"VASP","slug":"VASP","link":"/tags/VASP/"},{"name":"日常","slug":"日常","link":"/tags/%E6%97%A5%E5%B8%B8/"},{"name":"mathematica","slug":"mathematica","link":"/tags/mathematica/"},{"name":"诗","slug":"诗","link":"/tags/%E8%AF%97/"},{"name":"物理","slug":"物理","link":"/tags/%E7%89%A9%E7%90%86/"},{"name":"力学","slug":"力学","link":"/tags/%E5%8A%9B%E5%AD%A6/"},{"name":"LAMMPS","slug":"LAMMPS","link":"/tags/LAMMPS/"},{"name":"MD","slug":"MD","link":"/tags/MD/"},{"name":"日记","slug":"日记","link":"/tags/%E6%97%A5%E8%AE%B0/"},{"name":"Elastica Rod","slug":"Elastica-Rod","link":"/tags/Elastica-Rod/"}],"categories":[{"name":"日常","slug":"日常","link":"/categories/%E6%97%A5%E5%B8%B8/"}]}