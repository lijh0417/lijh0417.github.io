{"pages":[{"title":"关于","text":"这里是得意喵喵的小窝~得意喵~生日：2000-04-17&amp;2000-11-22就读院校：USTC&amp;XJTU兴趣：钢琴 长笛 猫咪 王者荣耀（特别是元歌）。。。。。。","link":"/about/index.html"},{"title":"友链","text":"http://staff.ustc.edu.cn/~xiajun/ http://staff.ustc.edu.cn/~fanjc/","link":"/links/index.html"}],"posts":[{"title":"写过的诗","text":"以前写过的一些诗，作为记录。 赏花微粉轻藏翠叶中去年还是满头空拟把今日作昨日明朝青墨不掩红 成吉思汗横扫塞北朔漠倏尔弓起雕落会将长枪东指平原万里逐鹰 对子歌雷对电 霓对虹 落日对长弓狂沙对乱石 明月对青冢千山外 万丈前 嘶噎对寒风还忆旧时苑 车水马如龙四十年来家国恨 三千里地山河残旧游在否林花谢了春红故国繁雄恰似一场空梦 无题蝉鸣清心戾荷光映流年石阶浅浅绿萝填且伴流水渐渐今日心中事后主当年情试问游鱼真知否幽苔石上生 忆江南江南好最是雨绵绵堤上细柳随风走岸边繁花映古楼何日复重游 江南美最美是苏州画舫楼上观荷叶网师园里赏琴筝人间无此声 江南忆最忆是旧游欢笑声中谈趣事环形岛上论沙鸥此生无此行 都江堰千丝万缕于心中青山一睹万事空峥嵘岁月仍在否万古长流且向东 渔家傲 秋思交大秋来风景异纷纷扬扬无留意枫叶满地金万里何日起星星点点随风去 倘若回首星夜里辉煌且随时光去黯然废物铺满地因何异谁道人生无对立 黑猫双瞳夜里如光且试爪下锋芒何畏山高地险信步还似平常 南乡子我是一只喵 飞檐走壁踩高跷 纵深飞跃何惧险黑猫惊叫声里水上漂烧鸡嘴上叼 隔壁金鱼爪中捞 小小兔崽口中嚼饿了(liao)烟灰喜欢喵喵喵 数学是什么小学时数学是卷子上的一百分我在前头同桌在后头初中时数学是几条有趣的图线我在外头答案在里头高中时数学是一支二部创意曲图像在上头公式在下头而今啊数学是一堆堆神奇的符号我在这头世界在那头","link":"/2022/01/30/%E6%88%91%E5%86%99%E8%BF%87%E7%9A%84%E8%AF%97/"},{"title":"纪念博客开通的第一天~","text":"第一次看到个人博客比特之理，让我萌生了制作个人博客的想法。最令人不爽的是，自己以前学习不善于总结。有些时候学过一些东西，或许有感悟，但是时间一长，很多想法根本无法发挥他们的价值，而且之前也没有很好的总结，很多时间被白白的浪费了(⊙﹏⊙)。于是，我想在自己的网站中把生活中的一些感悟与思考总结起来，包括但不限于： 生活感悟 钢琴&amp;长笛 基础数学、物理 基础力学 mathematica MD DFT","link":"/2022/01/29/%E7%BA%AA%E5%BF%B5%E5%8D%9A%E5%AE%A2%E5%BC%80%E9%80%9A%E7%9A%84%E7%AC%AC%E4%B8%80%E5%A4%A9~/"},{"title":"收集的mathematica壁纸和图标","text":"分享一些wolfram壁纸，Logo以及复刻Logo的程序。 wolfram壁纸下面分享几张收藏的wolfram壁纸： wolfram小图标分享一些wolfram的小图标，可以用来制作wolfram手机主题。之前对利用wolfram图标制作手机主题热衷了一段时间，但是制作的手机主题需要通过魔秀桌面来完成，个人能力还不足以开发一个真正的wolfram主题。其次，网上找到的图标质量参差不齐，wolfram的图标太少，用来替代app图标不直观。因此，后来就没有再进行完善了。。。。。。＞﹏＜制作的wolfram手机主题太丑了，ヽ（≧□≦）ノ连我自己也看不下去。。。。。。把图标的背景去除用的是mathematica的RemoveBackground命令，注意需要导出png格式。 mathematica Logo复刻对于mma的logo，还可以进行复刻： 123456789101112131415161718Clear[&quot;`*&quot;]; w[col_, r_] := Module[{p = Riffle[CirclePoints[{0.7*r, 0}, 10], CirclePoints[{r, (2*Pi)/20}, 10]]}, {col, FilledCurve@Line[p~Join~{p[[1]]}]}]; n[col_, r_, a_] := Module[{p = Riffle[CirclePoints[{0.2*a*r, Pi/10}, 5], CirclePoints[{0.8*r, (3 Pi)/10}, 5]]}, p = p~Join~{p[[1]], p[[2]]}; {col, FilledCurve@ Table[BezierCurve[p[[2 i ;; 2 i + 2]]], {i, 1, 5}]}] Manipulate[ Graphics[{w[Red, 1.05*r], n @@@ ({{White, Red, White, Red}, {1*r, 0.73*r, 0.5*r, 0.3*r}, {1*r, 1.4*r, 1.7*r, 1.8*r}} // Transpose)} // Flatten], {r, 0.8, 1.5}] 效果如下：内部图形的弯曲程度可以进行调节。","link":"/2022/01/30/%E6%94%B6%E9%9B%86%E7%9A%84mathematica%E5%A3%81%E7%BA%B8%E5%92%8C%E5%9B%BE%E6%A0%87/"},{"title":"用mathematica去水印","text":"mathematica去除学习资料中的水印。 如下图：比较简单，对于学习资料中的水印来说。 效果图：","link":"/2022/01/30/%E7%94%A8mathematica%E5%8E%BB%E6%B0%B4%E5%8D%B0/"},{"title":"用mathematica实现剪力弯矩图的解析求解以及示意图绘制","text":"介绍在材料力学课程中绘制剪力图，弯矩图以及挠度曲线 是求解梁变形问题的基础。在习题中，载荷往往得到了简化：恒定载荷 或者线分布载荷 。实际工程中，如果载荷分布可以利用查表法进行求解，容易解得梁的挠度等参数，但是如果载荷是任意分布的，这时候求解梁的变形问题就需要利用计算机来求解。一个基本的想法是，利用微元法，先把梁上的载荷按长度细分，然后拟合出一个载荷分布函数再求解。但是，拟合出来的函数往往不是那么的简单 ，人力计算几乎很难做到。 除此之外，对于梁的挠度曲线在工程上一般会使用三次函数来近似，并非一个解析的结果。利用mathematica强大的符号运算功能可以得到挠度曲线的解析形式 。 以前想过做一个app，后来发现ipad应用商店已经有了(((φ(◎ロ◎;)φ))套了个gui) 基本思想梁一般分为悬臂梁，简支梁，外伸梁三种样式。外伸梁和简支梁在求解形式上是相同的，只是支座位置不同，悬臂梁与二者不同。 具体步骤： 利用受力以及力矩平衡解出两个滑动铰支座的内力（或悬臂梁的约束力和约束力矩）。 把梁上作用的力，力矩，载荷以及载荷产生的力矩三者进行参数化建立关于他们对位置坐标 x 的密度函数。 利用力以及力矩平衡方程对密度函数进行积分求得剪力以及弯矩随位置 x 的分布函数。 利用弯矩与挠度的曲线的关系求解挠度曲线。 规定： 外力 ：向下为正 。 支座反力 ：向上为正。 外力矩 ：顺时针为正。 由受力平衡与力矩平衡可以解出任意截面内的剪力与弯矩。 其中: 由于挠度曲线二阶导 正比于弯矩 ，求得弯矩可以得到挠度曲线 程序实现：mathematica代码如下(EI 在假设为1 ，且梁的长度 设定为1 )： 外力及力矩： 以2*n数组给出，第一行为位置，第二行为大小 载荷： 以3*n的数组给出，第一行为载荷函数，输入格式为纯函数，第二行为载荷起点位置，第三行为载荷终点位置 支座位置： 以1*2数组给出，为两个支座位置 简支梁： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647Clear[&quot;*`&quot;];xb[F_, M_, Q_, X_] := Module[{force, moment, f0, m0, v, y, x, p, q}, force = Total[Last@F] + Total[MapThread[Integrate[#1[x], {x, #2, #3}] &amp;, Q]]; moment = Total[MapThread[#1*#2 &amp;, F]] + Total[Last@M] + Total[MapThread[Integrate[#1[x]*x, {x, #2, #3}] &amp;, Q]]; sol = Solve[{p + q == force, X[[1]]*p + X[[2]]*q == moment}, {p, q}]; p = p /. sol[[1, 1]]; q = q /. sol[[1, 2]]; f0 = Integrate[(p*DiracDelta[x - X[[1]]] + q*DiracDelta[x - X[[2]]] + Total[MapThread[-#2*DiracDelta[x - #1] &amp;, F]] + force*DiracDelta[x] - Total[MapThread[#1[ x]*(HeavisideTheta[x - #2] - HeavisideTheta[x - #3]) &amp;, Q]]), x]; m0 = Integrate[(Total[MapThread[x*#2*DiracDelta[x - #1] &amp;, F]] + Total[ MapThread[ x*#1[x]*(HeavisideTheta[x - #2] - HeavisideTheta[x - #3]) &amp;, Q]] + Total[MapThread[#2*DiracDelta[x - #1] &amp;, M]] - x*(p*DiracDelta[x - X[[1]]] + q*DiracDelta[x - X[[2]]])), x] + f0*x; sol = DSolve[{y''[x] == m0, y[X[[1]]] == 0, y[X[[2]]] == 0}, y[x], x]; v = -y[x] /. sol[[1]]; Grid[{{&quot;剪力图&quot;, Plot[f0, {x, 0, 1}, FrameLabel -&gt; {&quot;x&quot;, &quot;F&quot;}, PlotTheme -&gt; &quot;Detailed&quot;, PlotLegends -&gt; &quot;F(x)&quot;, PlotLabel -&gt; Style[&quot;剪力图&quot;, Bold], Exclusions -&gt; None, PlotStyle -&gt; Red]}, {&quot;弯矩图&quot;, Plot[m0, {x, 0, 1}, FrameLabel -&gt; {&quot;x&quot;, &quot;M&quot;}, PlotTheme -&gt; &quot;Detailed&quot;, PlotLegends -&gt; &quot;M(x)&quot;, PlotLabel -&gt; Style[&quot;弯矩图&quot;, Bold], Exclusions -&gt; None, PlotStyle -&gt; Green]}, {&quot;挠度曲线&quot;, Plot[-v, {x, 0, 1}, AxesLabel -&gt; {&quot;x&quot;, &quot;y&quot;}, PlotTheme -&gt; &quot;Detailed&quot;, PlotLabel -&gt; &quot;挠度曲线&quot;, PlotLegends -&gt; &quot;y(x)&quot;, FrameLabel -&gt; {&quot;x&quot;, &quot;y&quot;}, PlotStyle -&gt; Blue, PlotRange -&gt; All]}}, Frame -&gt; All] ] 悬臂梁： 12345678910111213141516171819202122232425262728293031323334353637Clear[&quot;*`&quot;];xb[F_, M_, Q_] := Module[{force, moment, f0, m0, v, y, x}, force = Total[Last@F] + Total[MapThread[Integrate[#1[x], {x, #2, #3}] &amp;, Q]]; moment = Total[MapThread[#1*#2 &amp;, F]] + Total[Last@M] + Total[MapThread[Integrate[#1[x]*x, {x, #2, #3}] &amp;, Q]]; f0 = Integrate[(Total[MapThread[-#2*DiracDelta[x - #1] &amp;, F]] + force*DiracDelta[x] - Total[MapThread[#1[ x]*(HeavisideTheta[x - #2] - HeavisideTheta[x - #3]) &amp;, Q]]), x]; m0 = Integrate[(Total[MapThread[x*#2*DiracDelta[x - #1] &amp;, F]] - moment*DiracDelta[x] + Total[MapThread[ x*#1[x]*(HeavisideTheta[x - #2] - HeavisideTheta[x - #3]) &amp;, Q]] + Total[MapThread[#2*DiracDelta[x - #1] &amp;, M]]), x] + f0*x; sol = DSolve[{y''[x] == -m0, y[0] == 0, y'[0] == 0}, y[x], x]; v = -y[x] /. sol[[1]]; Grid[{{&quot;剪力图&quot;, Plot[f0, {x, 0, 1}, FrameLabel -&gt; {&quot;x&quot;, &quot;F&quot;}, PlotTheme -&gt; &quot;Detailed&quot;, PlotLegends -&gt; &quot;F(x)&quot;, PlotLabel -&gt; Style[&quot;剪力图&quot;, Bold], Exclusions -&gt; None, PlotStyle -&gt; Red]}, {&quot;弯矩图&quot;, Plot[m0, {x, 0, 1}, FrameLabel -&gt; {&quot;x&quot;, &quot;M&quot;}, PlotTheme -&gt; &quot;Detailed&quot;, PlotLegends -&gt; &quot;M(x)&quot;, PlotLabel -&gt; Style[&quot;弯矩图&quot;, Bold], Exclusions -&gt; None, PlotStyle -&gt; Green]}, {&quot;挠度曲线&quot;, Plot[v, {x, 0, 1}, AxesLabel -&gt; {&quot;x&quot;, &quot;y&quot;}, PlotTheme -&gt; &quot;Detailed&quot;, PlotLabel -&gt; &quot;挠度曲线&quot;, PlotLegends -&gt; &quot;y(x)&quot;, FrameLabel -&gt; {&quot;x&quot;, &quot;y&quot;}, PlotStyle -&gt; Blue]}}, Frame -&gt; All] ] 给出绘图的函数，可用于绘制标准的梁受力示意图（示意图中物理量大小输入最好由±1代替）： 简支梁： 12345678910111213141516171819202122232425262728293031323334353637Clear[&quot;`*&quot;];cp[F_, M_, Q_, X_] := Module[{wall, beam, moment, force, label, load}, wall = {Triangle[{{X[[1]], 0}, {X[[1]] - 0.01, -0.01*Sqrt[3]}, {X[[1]] + 0.01, -0.01* Sqrt[3]}}], Triangle[ {{X[[2]], 0}, {X[[2]] - 0.01, -0.01*Sqrt[3]}, {X[[2]] + 0.01, -0.01* Sqrt[3]}}]}; beam = {Thick, Line[{{0, 0}, {1, 0}}]}; circle[x_, n_] := Module[{k}, If[n == 1, Arrow@ Table[{x + 0.03*Cos[k], 0.03*Sin[k]}, {k, 0, 1.5*Pi, 0.1 Pi}], Arrow@ Table[{x + 0.03*Cos[k], 0.03*Sin[k]}, {k, 1.5*Pi, 0, -0.1 Pi}]]]; force = {Red, MapThread[Arrow[{{#1, 0}, {#1, 0.1*#2}}] &amp;, F]}; moment = {Green, Evaluate[MapThread[circle[#1, #2] &amp;, M]]}; label = MapThread[ Text, {Subscript[&quot;F&quot;, #] &amp; /@ Range[Length[First@F]], Transpose[{First@F + 0.04, (#*0.13)/Abs[#] &amp; /@ Last@F}]}]~ Join~MapThread[ Text, {Subscript[&quot;M&quot;, #] &amp; /@ Range[Length[First@M]], Transpose[{First@M, (Abs[#]*0.05)/Abs[#] &amp; /@ Last@M}]}]~Join~ MapThread[Text, {Subscript[&quot;q&quot;, #] &amp; /@ Range[Length[First@Q]], MapThread[{(#2 + #3)/2 + 0.02, Sign[#1[(#2 + #3)/2]]*0.15 } &amp;, Q]}]; load = {Blue, Thin, Arrowheads[0.02], MapThread[ Arrow /@ Table[{{x, 0.08*#1[x]/Abs@Max[#1 /@ Range[#2, #3, (#3 - #2)/10]]}, {x, 0}}, {x, #2, #3, (#3 - #2)/5}] &amp;, Q]}; Show[Graphics[{Arrowheads[0.02], wall, moment, force, beam, label, load}]]]; 悬臂梁： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869Clear[&quot;`*&quot;];cp[F_, M_, Q_] := Module[{wall, beam, moment, force, label, load}, wall = {Line[{{0, 0.2}, {0, -0.2}}], Line /@ Transpose@{Transpose[{0*Range[10], 0.2 - 0.04*(Range@10 - 1)}], Transpose[{ConstantArray[-0.03, 10], 0.15 - 0.04*(Range@10 - 1)}]}}; beam = {Thick, Line[{{0, 0}, {1, 0}}]}; circle[x_, n_] := Module[{k}, If[n == 1, Arrow@ Table[{x + 0.03*Cos[k], 0.03*Sin[k]}, {k, 0, 1.5*Pi, 0.1 Pi}], Arrow@ Table[{x + 0.03*Cos[k], 0.03*Sin[k]}, {k, 1.5*Pi, 0, -0.1 Pi}]]]; force = {Red, MapThread[Arrow[{{#1, 0}, {#1, 0.1*#2}}] &amp;, F]}; moment = {Green, Evaluate[MapThread[circle[#1, #2] &amp;, M]]}; label = MapThread[ Text, {Subscript[&quot;F&quot;, #] &amp; /@ Range[Length[First@F]], Transpose[{First@F + 0.04, (#*0.13)/Abs[#] &amp; /@ Last@F}]}]~ Join~MapThread[ Text, {Subscript[&quot;M&quot;, #] &amp; /@ Range[Length[First@M]], Transpose[{First@M, (Abs[#]*0.05)/Abs[#] &amp; /@ Last@M}]}]~Join~ MapThread[Text, {Subscript[&quot;q&quot;, #] &amp; /@ Range[Length[First@Q]], MapThread[{(#2 + #3)/2 + 0.02, Sign[#1[(#2 + #3)/2]]*0.15 } &amp;, Q]}]; load = {Blue, Thin, Arrowheads[0.02], MapThread[ Arrow /@ Table[{{x, 0.08*#1[x]/Abs@Max[#1 /@ Range[#2, #3, (#3 - #2)/10]]}, {x, 0}}, {x, #2, #3, (#3 - #2)/5}] &amp;, Q]}; Show[Graphics[{Arrowheads[0.02], wall, moment, force, beam, label, load}]]]; 最后来几张效果图： 说明一下，剪力图，弯矩图，挠度曲线和受力图没有选用对应的参数，只是作为一个示意。","link":"/2022/03/18/%E7%94%A8mathematica%E5%AE%9E%E7%8E%B0%E5%89%AA%E5%8A%9B%E5%BC%AF%E7%9F%A9%E5%9B%BE%E7%9A%84%E8%A7%A3%E6%9E%90%E6%B1%82%E8%A7%A3%E4%BB%A5%E5%8F%8A%E7%A4%BA%E6%84%8F%E5%9B%BE%E7%BB%98%E5%88%B6/"},{"title":"莱布尼茨公式为什么和二项式定理相似？","text":"偶然发现了这个有趣的类比~~在高等数学中，莱布尼茨公式非常常见。但是，作为工科学生，在工科数学分析基础上没看到证明。作为一个不严格的理解，记录如下。 Leibniz公式Leibniz公式与二项式定理很像，那么他们又有什么关系呢？一个有趣的想法是，可以定义一种算子: 。 一般的，我们定义一种东西，是因为他可以符合某种好的性质。 那么这个算子的性质: 只与u作用，与ν不作用，对称的， 也只与v作用，与u不作用。他们与函数作用的结果是对这个函数求导。n个 依次与u作用，表示对u求n阶导，可以记为 ， 也同理。 这样就清楚了: 如果我想对uv乘积进行求导，我就把它记为: 对uv想求二阶导就对原有的一阶导再乘以 ，即 ， 不难验证这样写法是正确的（归纳法）。 如果n阶导数的话，就有: 小结 初看Leibniz公式与二项式定理很像，但是为什么还是值得思考的。如果不是两个函数相乘而是很多个。那么，就可以定义很多类似于 的东西，推广出来应该就是广义二项式定理。 其实，这个问题从高中就开始困扰我，知道大学才明白一点。 容易发现，导数的线性性质在这里表现为乘法的分配律。","link":"/2022/03/18/%E8%8E%B1%E5%B8%83%E5%B0%BC%E8%8C%A8%E5%85%AC%E5%BC%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%92%8C%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86%E7%9B%B8%E4%BC%BC%EF%BC%9F/"},{"title":"n维球以及n维正n+1面体的体积与表面积","text":"一个递归方法的应用: 求 递归表达式为: 12Simplify@RSolve[{f[n] == x^n*Exp[x] - n*f[n - 1], f[1] == (x - 1) Exp[x]}, f[n], n] // TraditionalForm 对球和正n+1面体:1 球: 换元后 123456789101112131415161718Clear[&quot;`*&quot;];g[n] = Integrate[Cos[x]^n, {x, -Pi/2, Pi/2}, Assumptions -&gt; n &gt; 0];RSolve[{a[n] == a[n - 1]*g[n], a[1] == 2}, a[n], n] // TraditionalForm ;f[n_] := (2 \\[Pi]^(n/2))/(n Gamma[n/2]);ListPlot[Table[(2 \\[Pi]^(n/2))/(n Gamma[n/2]), {n, 0, 20}]];ListPlot[Table[f[x], {x, 0, 20, 0.02}], PlotTheme -&gt; &quot;Detailed&quot;]Max[Table[f[x], {x, 5, 6, 0.0001}]];ListPlot[Table[(f[x + 0.0001] - f[x])/0.0001, {x, 5, 6, 0.0001}]];FindRoot[D[f[x], x], {x, 1, 10}];L[n_] = Simplify[n*f[n]];ListPlot[Table[L[n], {n, 0, 20, 0.02}], PlotTheme -&gt; &quot;Detailed&quot;];FindRoot[D[L[x], x], {x, 1, 10}];Integrate[f[2*x], {x, 0, Infinity}, Assumptions -&gt; x \\[Element] Integer]Sum[f[x], {x, 0, Infinity}]Sum[L[2*n + 1], {n, 0, Infinity}] 体积系数: 表面积系数: 绘图: n维球在n=5.257是体积系数有最大值,5.27777 在n=7.257时表面积系数有最大值,33.1612 为啥呢? 我也不知道了. 体积系数和表面积系数是收敛的: 求和有: 体积系数和： 为误差函数。 偶数项和: 奇数项和： 表面积系数和： 偶数项和： 奇数项和： 2 正n+1面体:高系数递推公式: 1H_n=\\sqrt{1-(\\frac{n-1}{n}H_{n-1})^2} 体积系数的递推公式： 12a[n_] := -((I^n Sqrt[(-1)^n (n + n^2)])/(Sqrt[2] n));RSolve[{b[n] == 1/n*a[n]*b[n - 1], b[2] == Sqrt[3]/4}, b[n], n]; 高系数： 体积系数: 表面积系数: 为什么会有复数? 不知道了.可以画幅频曲线，相频曲线？？ 注：以前看过网上有一个日本高考题，证明 ，使用的线性化方法。 可以出一个题：证明偶数维球体积系数之和大于21.","link":"/2022/03/18/n%E7%BB%B4%E7%90%83%E4%BB%A5%E5%8F%8An%E7%BB%B4%E6%AD%A3n-1%E9%9D%A2%E4%BD%93%E7%9A%84%E4%BD%93%E7%A7%AF%E4%B8%8E%E8%A1%A8%E9%9D%A2%E7%A7%AF/"},{"title":"用mathematica实现均值不等式可视化","text":"调和—几何—算数—平方不等式。 调和平均数，几何平均数，算术平均数，平方平均数之间又如下关系：（二元） 利用mathematica可以实现可视化： n代表不同的伪随机种子 12345678910111213141516171819202122232425262728Clear[&quot;`*&quot;];Manipulate[ Row[{scene = RandomInstance[ GeometricScene[{a, b, c, d, e, f, o}, {GeometricStep[{Triangle[{a, b, c}], CircleThrough[{a, b, c, e}, o], o == Midpoint[{a, b}], Line[{d, e}], Line[{a, d, o, b}], Line[{c, f, o}], GeometricAssertion[{Line[{a, b}], Line[{c, d}]}, &quot;Perpendicular&quot;], GeometricAssertion[{Line[{d, f}], Line[{c, o}]}, &quot;Perpendicular&quot;], GeometricAssertion[{Line[{a, b}], Line[{o, e}]}, &quot;Perpendicular&quot;] }, &quot;平均值不等式&quot;]} ], RandomSeeding -&gt; n ], {AA, BB, CC, DD} = {EuclideanDistance [d, e], EuclideanDistance [o, e], EuclideanDistance [d, c], EuclideanDistance [c, f]} /. scene[&quot;Points&quot;]; Column[{&quot; \\!\\(\\*SqrtBox[FractionBox[\\(\\*SuperscriptBox[\\(x\\), \\(2\\\\)] + \\*SuperscriptBox[\\(y\\), \\(2\\)]\\), \\(2\\)]]\\)=de=&quot; &lt;&gt; ToString[AA], &quot; \\!\\(\\*FractionBox[\\(x + y\\), \\(2\\)]\\)=oe=&quot; &lt;&gt; ToString[BB], &quot; \\!\\(\\*SqrtBox[\\(xy\\)]\\)=cd=&quot; &lt;&gt; ToString[CC], &quot; \\!\\(\\*FractionBox[\\(2 xy\\), \\(x + y\\)]\\)=cf=&quot; &lt;&gt; ToString[DD]}]}] , {n, 1, 10, 1}, ControlPlacement -&gt; Top]","link":"/2022/03/18/%E7%94%A8mathematica%E5%AE%9E%E7%8E%B0%E5%9D%87%E5%80%BC%E4%B8%8D%E7%AD%89%E5%BC%8F%E5%8F%AF%E8%A7%86%E5%8C%96/"},{"title":"用mathematica推导与验证Bertrand定理","text":"Bertrand定理描述了闭合轨道条件下具有幂函数形式的有心力的可能情况 1公式推导Bertrand定理指出，对于有心力场，位势 ，只有当 时，运动轨道才是闭合的。 根据https://zh.wikipedia.org/wiki/%E4%BC%AF%E7%89%B9%E8%98%AD%E5%AE%9A%E7%90%86中的证明思路，可以利用mathematica进行推导。 代码: 1234567891011121314151617181920212223242526272829303132Clear[&quot;`*&quot;]J[x_] := A*x^(1 - \\[Beta]^2);ruleJ = First[Solve[D[J[x], x] == (1 - \\[Beta]^2), A]];rule1 := Table[Cos[k*\\[Beta]*\\[Theta]] -&gt; 0, {k, 1, 9}]rule2 = {h0 -&gt; A*h1^2, h2 -&gt; B*h1^2, h3 -&gt; F*h1^3}~Join~ Fold[ReplaceAll, {J1 -&gt; 1 - \\[Beta]^2, J2 -&gt; D[J[x], {x, 2}], J3 -&gt; D[J[x], {x, 3}]}, ruleJ~Append~(x -&gt; u0)]~Join~ Table[Power[h1, k] -&gt; 0, {k, 4, 9}];\\[Eta][\\[Theta]_] := h0 + h1*Cos[\\[Beta]*\\[Theta]] + h2*Cos[2*\\[Beta]*\\[Theta]] + h3*Cos[3*\\[Beta]*\\[Theta]]x = D[\\[Eta][\\[Theta]], {\\[Theta], 2}] + \\[Beta]^2*\\[Eta][\\[Theta]];y = TrigReduce[(1/2 \\[Eta][\\[Theta]]^2*J2 + 1/6 \\[Eta][\\[Theta]]^3*J3)];a = Coefficient[ x, {Cos[\\[Beta]*\\[Theta]], Cos[2 \\[Beta]*\\[Theta]], Cos[3 \\[Beta]*\\[Theta]]}];b = Coefficient[ y, {Cos[\\[Beta]*\\[Theta]], Cos[2 \\[Beta]*\\[Theta]], Cos[3 \\[Beta]*\\[Theta]]}];PrependTo[a, x /. rule1];PrependTo[b, y /. rule1];s = Fold[ReplaceAll, {a, b}, rule2];equ1 = MapThread[#1 == #2 &amp;, s];sol = Solve[equ1, {A, B, F, \\[Beta]}] 2 数值验证利用mathematica可以对Bertrand定理做出验证。 如图绘制了不同有心力 情况下的运动轨道。 可以发现只有 时，轨道才是闭合的。 图上传不了，分享个结果的pdf链接。 https://maiimg.com/pdf/?e=auNKkKmHMM43s6 代码： 123456789101112131415161718Clear[&quot;`*&quot;]F[x_, k_] := -400/x^k;equ[k_] := {\\[Rho]''[t] - \\[Theta]'[t]^2*\\[Rho][t] == F[\\[Rho][t], k], \\[Theta]''[t]*\\[Rho][t] + 2*\\[Theta]'[t]*\\[Rho]'[t] == 0, \\[Theta][0] == 0, \\[Rho][0] == 1, \\[Rho][0] \\[Theta]'[0] == 10, \\[Rho]'[0] == 10};sol[k_] := NDSolve[equ[k], {\\[Theta], \\[Rho]}, {t, 0, 10}];Grid[Partition[Table[ ParametricPlot[ Evaluate[{\\[Rho][t]*Cos[\\[Theta][t]], \\[Rho][t]* Sin[\\[Theta][t]]} /. First[sol[k]]], {t, 0, 10}, PlotRange -&gt; All, PlotTheme -&gt; &quot;Scientific&quot;, PlotLabel -&gt; &quot;有心力场轨道 \\[Alpha]=&quot; &lt;&gt; ToString[k], FrameLabel -&gt; {&quot;x&quot;, &quot;y&quot;}] , {k, -3.6, 2.7, 0.1}], 8], Frame -&gt; All]","link":"/2022/03/18/%E7%94%A8mathematica%E6%8E%A8%E5%AF%BC%E4%B8%8E%E9%AA%8C%E8%AF%81Bertrand%E5%AE%9A%E7%90%86/"},{"title":"Busoni改编的Chaconne","text":"Chaconne in d minor BWV1004 小提琴solo，Bach原作，被Busoni改编成钢琴曲，带有一定炫技成分，十分绚丽。 四年前在一次音乐会上听一位同学演奏这首曲目，当时留下了深刻的印象，十分想练习。奈何能力不够，一直拖到了现在，目前第一部分高潮结束前已经练完了。但是感觉自己对这首曲目的结构一无所知，照着谱干练，典型的傻子弹琴，但又不是专业人士，无法对音乐结构有确切把握，难啊！目前喜欢的版本有Helene Grimaud演奏的版本，这个版本流传最广，处理十分细腻，感觉都是非常经典的处理方式。Shura Cherkassky 演奏的版本感觉有不一样的味道，特别是第一段高潮的部分可以明显的听出两个声部，中间转调后的声部也非常清晰。虽然有错音，但是非常好听。感觉应该和Shura本人的练琴方式有关，Shura用一种非常慢的方式练琴，处理起来必然比其他人更加细腻。第一次看到他演奏的视频，弹的是一首吕利的巴洛克小品。当时就被视频中慈眉善目的老头的琴声吸引了，看他的面相也大致能推测出他的音乐风格。还有两个喜欢的版本是Olivier Latry和Christoph Reinhold的管风琴版，感觉管风琴的庄重感和多声部的表现远胜于钢琴。喜欢的原因有两个：1 能够更好的表现出多个声部，Helene Grimaud的版本听着是很爽，但是爽完就完了，没有那种回味无穷的感觉。管风琴版本几乎每一个变奏主题，可以听出另一个声部对第一个主题的重复，似隐似现，回味无穷。2 管风琴有些地方的处理是和钢琴十分不同的。比如第65小节，钢琴处理会表现得很活跃，速度比较快（参见Helene的版本），但是管风琴就明显有减慢的处理，往后拖一些，感觉更加庄重了。chaconne好听难练，真应了那句俗语：樱桃好吃树难栽。无论如何，慢慢打磨吧，现在弹不好，慢慢练练，到了三十几岁总能弹得差不多。实在不行，还有退休后的时光呢，哈哈哈。 附上Busoni改编的chaconne链接。Busoni-chaconne","link":"/2022/04/10/Busoni%E6%94%B9%E7%BC%96%E7%9A%84Chaconne/"},{"title":"用mathematica求解相对追逐问题","text":"相对追逐问题：几个人处于n边形的定点上，前一个人朝着后一个人运动。详情见https://en.wikipedia.org/wiki/Mice_problem 理论上可以证明，追踪曲线解析解为对数螺线。 利用mathematica可以依次数值求解微分方程绘制轨迹曲线。 12345678910111213141516171819Clear[&quot;`*&quot;]n = 10;a = CirclePoints[n];b = 0.1;equ = Flatten@ Table[{Sqrt[y[k]'[t]^2 + x[k]'[t]^2] == b, (y[Mod[k + 1, n, 1]][t] - y[k][t])* D[x[k][t], t] == (x[Mod[k + 1, n, 1]][t] - x[k][t])* D[y[k][t], t], Thread[{x[k][0], y[k][0]} == a[[k]]], Thread[{x[k]'[0], y[k]'[0]} == b*Normalize[a[[Mod[k + 1, n, 1]]] - a[[k]]]]}, {k, 1, n}];sol = NDSolve[equ, Flatten[{x[#], y[#]} &amp; /@ Range@n], {t, 0, 32}, Method -&gt; {&quot;EquationSimplification&quot; -&gt; &quot;Residual&quot;}] // Flatten;Plot[Evaluate@Through[Values[sol][t]], {t, 0, 32}, ImageSize -&gt; Large]Show[{ParametricPlot[ Evaluate@Partition[Through[Values[sol][t]], 2], {t, 0, 30}, PlotTheme -&gt; &quot;Scientific&quot;, PlotLabel -&gt; &quot;Bugs' movation&quot;, FrameLabel -&gt; {&quot;x&quot;, &quot;y&quot;}] , Graphics[Line[Append[CirclePoints[n], First@CirclePoints[n]]]]}]","link":"/2022/03/18/%E7%94%A8mathematica%E6%B1%82%E8%A7%A3%E7%9B%B8%E5%AF%B9%E8%BF%BD%E9%80%90%E9%97%AE%E9%A2%98/"},{"title":"用mathematica计算微分几何中的部分量","text":"mathematica在微分几何中的几个应用： 动态绘制空间曲线的密切平面 求曲面中的一些基本量 求曲面第一基本形式 求曲面第二基本形式 求曲面向量两个方向夹角 求曲面域的面积 动态绘制Dipan指标线 动态绘制空间曲线密切平面123456789101112131415Clear[&quot;`*&quot;]f[x_, y_, z_, t0_] := Block[{X, Y, Z}, Dot[Cross[{x'[t0], y'[t0], z'[t0]}, {x''[t0], y''[t0], z''[t0]}], {X - x[t0], Y - y[t0], Z - z[t0]}]]Manipulate[ Show[{ParametricPlot3D[{Cos[k], Sin[k], k}, {k, -\\[Pi], \\[Pi]}, PlotRange -&gt; {{-3, 3}, {-3, 3}, {-4, 4}}, Boxed -&gt; False, Axes -&gt; False], ContourPlot3D[ f[Cos, Sin, # &amp;, t] == 0, {X, Cos[t] - 0.5, Cos[t] + 0.5}, {Y, Sin[t] - 0.5, Sin[t] + 0.5}, {Z, t - 0.5, t + 0.5}], ListPointPlot3D[{{Cos[t], Sin[t], t}}, PlotStyle -&gt; {Red, PointSize[Large]}]}] , {t, -\\[Pi], \\[Pi]}] 曲面论求曲面基本参数，第一、第二基本形式，方向角、曲面域的面积1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950Clear[&quot;`*&quot;]SurfaceParameters[r_] := Block[{n, E1, F1, G1, L2, M2, N2, u, v}, n = Normalize[Cross[D[r[u, v], u], D[r[u, v], v]]]; E1 = Dot[D[r[u, v], u], D[r[u, v], u]]; F1 = Dot[D[r[u, v], u], D[r[u, v], v]]; G1 = Dot[D[r[u, v], v], D[r[u, v], v]]; L2 = Dot[n, D[r[u, v], {u, 2}]]; M2 = Dot[n, D[D[r[u, v], v], u]]; N2 = Dot[n, D[r[u, v], {v, 2}]]; Grid[{{&quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;}, {E1, F1, G1, L2, M2, N2}} // Simplify[#, {u, v} \\[Element] PositiveReals] &amp;, Frame -&gt; All]]FirstBasicForm[r_] := Block[{u, v, du, dv}, n = Normalize[Cross[D[r[u, v], u], D[r[u, v], v]]]; E1 = Dot[D[r[u, v], u], D[r[u, v], u]]; F1 = Dot[D[r[u, v], u], D[r[u, v], v]]; G1 = Dot[D[r[u, v], v], D[r[u, v], v]]; (E1*du^2 + 2*F1*du*dv + G1*dv^2) // Simplify[#, {u, v} \\[Element] PositiveReals] &amp;]SecondBasicForm[r_] := Block[{u, v, du, dv}, n = Normalize[Cross[D[r[u, v], u], D[r[u, v], v]]]; L2 = Dot[n, D[r[u, v], {u, 2}]]; M2 = Dot[n, D[D[r[u, v], v], u]]; N2 = Dot[n, D[r[u, v], {v, 2}]]; (L2*du^2 + 2*M2*du*dv + N2*dv^2) // Simplify[#, {u, v} \\[Element] PositiveReals] &amp;]SurfaceAngle[r_, r0_, r1_, r2_] := Block[{du, dv, \\[Delta]u, \\[Delta]v, u, v}, E1 = Dot[D[r[u, v], u], D[r[u, v], u]]; F1 = Dot[D[r[u, v], u], D[r[u, v], v]]; G1 = Dot[D[r[u, v], v], D[r[u, v], v]]; ReplaceAll[ ArcCos[(E1*du*\\[Delta]u + F1*(du*\\[Delta]v + dv*\\[Delta]u) + G1*dv*\\[Delta]v)/(Sqrt[E1*du^2 + 2*F1*du*dv + G1*dv^2]*Sqrt[ E1*\\[Delta]u^2 + 2*F1*\\[Delta]u*\\[Delta]v + G1*\\[Delta]v^2])], {du -&gt; r1[[1]], dv -&gt; r1[[2]], \\[Delta]u -&gt; r2[[1]], \\[Delta]v -&gt; r2[[2]], u -&gt; r0[[1]], v -&gt; r0[[2]]}]]ManifoldArea[r_, R1_, R2_] := Block[{u, v}, E1 = Dot[D[r[u, v], u], D[r[u, v], u]]; F1 = Dot[D[r[u, v], u], D[r[u, v], v]]; G1 = Dot[D[r[u, v], v], D[r[u, v], v]]; Integrate[Sqrt[ E1*G1 - F1^2], Prepend[R1, u], Prepend[R2, v]]] 一些测试范例123456789101112131415161718192021SurfaceAngle[{Cos[#2]*#1, Sin[#2] #1, 3*#2} &amp;, {3, 1}, {1, 1}, {-1, 1}] // NSimplify[FirstBasicForm[{Cos[#2]*#1, Sin[#2] #1, a*#2} &amp;], {a, Cos[v]} \\[Element] Reals];Simplify[SecondBasicForm[{Cos[#2]*#1, Sin[#2] #1, a*#2} &amp;], {a, Cos[v], Sin[v]} \\[Element] PositiveReals];Simplify[SurfaceParameters[ R*{Cos[#2]*Cos[#1], Sin[#1]*Cos[#2], Sin[#2]} &amp;], {R, u, v, Cos[v]} \\[Element] PositiveReals];Simplify[SurfaceParameters[{a*#2*Cos[#1], a*#2*Sin[#1], a*#2^2} &amp;], {a, u, v} \\[Element] PositiveReals];ManifoldArea[ R*{Cos[#2]*Cos[#1], Sin[#1]*Cos[#2], Sin[#2]} &amp;, {0, 2 \\[Pi]}, {-\\[Pi]/2, \\[Pi]/2}] // Simplify[#, R &gt; 0] &amp;;FirstBasicForm[{#1 Cos[#2], #1 Sin[#2], #1 + #2} &amp;];FirstBasicForm[{#2 Cos[#1], #2 Sin[#1], Sqrt[#2^2 - 1]} &amp;] /. {u -&gt; ArcTan[x] + y, v -&gt; Sqrt[x^2 + 1], du -&gt; 1/(1 + x^2) dx + dy, dv -&gt; (x*dx)/Sqrt[x^2 + 1]} // Simplify;Simplify[SecondBasicForm[{R*Cos[#2] Cos[#1], R*Cos[#2]*Sin[#1], R*Sin[#2]} &amp;], {R, u, v, Cos[u], Sin[u], Cos[v], Sin[v]} \\[Element] PositiveReals] 切平面与法线1234567891011121314151617TangentPlane[r_, r0_] := Block[{u, v}, Det[{{X, Y, Z} - r @@ r0, D[r @@ {u, v}, u], D[r @@ {u, v}, v]} /. {u -&gt; r0[[1]], v -&gt; r0[[2]]}] == 0 // Simplify]CurveNormal[r_, r0_] := Block[{u, v}, ((X - (r @@ r0)[[1]])/ Det[{{D[r @@ {u, v}, u][[2]], D[r @@ {u, v}, v][[2]]}, {D[r @@ {u, v}, u][[3]], D[r @@ {u, v}, v][[3]]}}] == (Y - (r @@ r0)[[2]])/ Det[{{D[r @@ {u, v}, u][[3]], D[r @@ {u, v}, v][[3]]}, {D[r @@ {u, v}, u][[1]], D[r @@ {u, v}, v][[1]]}}] == (Z - (r @@ r0)[[3]])/ Det[{{D[r @@ {u, v}, u][[1]], D[r @@ {u, v}, v][[1]]}, {D[r @@ {u, v}, u][[2]], D[r @@ {u, v}, v][[2]]}}])] 测试范例1234567891011121314*范例*TangentPlane[{a*Cos[#1]*Cos[#2], a*Cos[#2]*Sin[#1], a*Sin[#2]} &amp;, {\\[Phi], \\[Theta]}]CurveNormal[{a*Cos[#1]*Cos[#2], a*Cos[#2]*Sin[#1], a*Sin[#2]} &amp;, {\\[Phi], \\[Theta]}] // SimplifyManipulate[ ContourPlot3D[ a Cos[\\[Theta]]*\\[Theta]* (a - Z Sin[\\[Theta]] - Cos[\\[Theta]] (X Cos[\\[Phi]] + Y Sin[\\[Phi]])) == 0, {X, -1, 1}, {Y, -1, 1}, {Z, -1, 1}] /. a -&gt; 1, {\\[Theta], -\\[Pi], \\[Pi]}, {\\[Phi], -\\[Pi], \\[Pi]}]ParametricPlot3D[{Cos[#1] #1*Cos[#2], #2 Cos[#2]*Sin[#1], Sin[#2]} &amp; @@ {\\[Phi], \\[Theta]}, {\\[Phi], -\\[Pi], \\[Pi]}, {\\\\[Theta], -\\[Pi], \\[Pi]}] /. a -&gt; 1 Dipan指标线1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Clear[&quot;`*&quot;]Dupin[r_, r0_] := Block[{u, v, x, y, \\[Rho], t}, n = Normalize[Cross[D[r[u, v], u], D[r[u, v], v]]]; L2 = Dot[n, D[r[u, v], {u, 2}]]; M2 = Dot[n, D[D[r[u, v], v], u]]; N2 = Dot[n, D[r[u, v], {v, 2}]]; sol = Solve[ Evaluate[(L2*x^2 + 2*M2*x*y + N2*y^2) /. {Abs[x_] -&gt; x, x -&gt; \\[Rho]*Cos[t], y -&gt; \\[Rho]*Sin[t]}] == 1, \\[Rho]] ; s = RotationTransform[{{0, 0, 1}, n}][{Abs[\\[Rho] /. sol[[1]]]* Cos[t], Abs[\\[Rho] /. sol[[1]]]*Sin[t], 0}]; TranslationTransform[ Dot[r @@ r0 - s /. t -&gt; 1, n /. {u -&gt; r0[[1]], v -&gt; r0[[2]]}]* n /. {u -&gt; r0[[1]], v -&gt; r0[[2]]}][s]]TangentPlane[r_, r0_] := Block[{u, v}, Det[{{X, Y, Z} - r @@ r0, D[r @@ {u, v}, u], D[r @@ {u, v}, v]} /. {u -&gt; r0[[1]], v -&gt; r0[[2]]}] == 0 // Simplify]Show[ {ParametricPlot3D[{Cos[u], Cos[v], Cos[u + v]}, {u, 0, 2 \\[Pi]}, {v, 0, 2 \\[Pi]}, PlotRange -&gt; 3, Boxed -&gt; False, Axes -&gt; None, Mesh -&gt; None], ParametricPlot3D[ Evaluate[ Dupin[{Cos[#1], Cos[#2], Cos[#1 + #2]} &amp;, {u, v}] /. {u -&gt; 1.5, v -&gt; 1}], {t, -\\[Pi], \\[Pi]}, PlotStyle -&gt; Red], ContourPlot3D[ Evaluate[ TangentPlane[{Cos[#1], Cos[#2], Cos[#1 + #2]} &amp;, {1.5, 1}]], {X, -4, 4}, {Y, -4, 4}, {Z, -4, 4}, Mesh -&gt; None, BoundaryStyle -&gt; None, ContourStyle -&gt; {Opacity[0.3], Green}], Graphics3D[{PointSize[Large], Red, Point[{Cos[#1], Cos[#2], Cos[#1 + #2]} &amp; @@ {1.5, 1}]}]}]Manipulate[Show[ {ParametricPlot3D[{Cos[u], Cos[v], Cos[u + v]}, {u, 0, 2 \\[Pi]}, {v, 0, 2 \\[Pi]}, PlotRange -&gt; 4, Boxed -&gt; False, Axes -&gt; None, Mesh -&gt; None], ParametricPlot3D[ Evaluate[ Dupin[{Cos[#1], Cos[#2], Cos[#1 + #2]} &amp;, {u, v}] /. {u -&gt; u0, v -&gt; v0}], {t, -\\[Pi], \\[Pi]}, PlotStyle -&gt; Red], ContourPlot3D[ Evaluate[ TangentPlane[{Cos[#1], Cos[#2], Cos[#1 + #2]} &amp;, {u0, v0}]], {X, -4, 4}, {Y, -4, 4}, {Z, -4, 4}, Mesh -&gt; None, BoundaryStyle -&gt; None, ContourStyle -&gt; {Opacity[0.3], Green}], Graphics3D[{PointSize[Large], Red, Point[{Cos[#1], Cos[#2], Cos[#1 + #2]} &amp; @@ {u0, v0}]}]}], {u0, 0.1, 2 \\[Pi]}, {v0, 0.1, 2 \\[Pi]}, ControlPlacement -&gt; Top]","link":"/2022/07/18/%E7%94%A8mathematica%E8%AE%A1%E7%AE%97%E5%BE%AE%E5%88%86%E5%87%A0%E4%BD%95%E4%B8%AD%E7%9A%84%E9%83%A8%E5%88%86%E9%87%8F/"},{"title":"宠物名片","text":"用mathematica可以制作一些宠物名片 12345678Clear[&quot;`*&quot;];p={{Item[烟灰.png,Alignment-&gt;Center],SpanFromLeft},{&quot;stuID&quot;,&quot;2196001122&quot;},{&quot;姓名&quot;,&quot;烟灰&quot;},{&quot;精神面貌&quot;,&quot;宠物&quot;},{&quot;主人&quot;,&quot;～～&quot;},{&quot;颜色&quot;,&quot;白色&quot;},{&quot;业余爱好&quot;,&quot;吃饭，睡觉&quot;},{Item[Style[&quot;学习成绩&quot;,Bold],Alignment-&gt;Center],SpanFromLeft},{&quot;语文&quot;,&quot;59&quot;},{&quot;数学&quot;,&quot;58&quot;},{&quot;英语&quot;,&quot;66&quot;},{Item[Style[&quot;光荣事迹&quot;,Bold],Alignment-&gt;Center],&quot;床上拉屎&quot;},{SpanFromAbove,&quot;叼樱桃&quot;},{SpanFromAbove,&quot;玩卫生纸&quot;},{SpanFromAbove,&quot;抓沙发&quot;}};p[[2;;7,1]]=Style[#,Bold]&amp;/@p[[2;;7,1]];p[[9;;11,1]]=Style[#,Bold]&amp;/@p[[9;;11,1]];Grid[p,Alignment-&gt;Left,Frame-&gt;All] 123456789Clear[&quot;`*&quot;];q={{&quot;光荣事迹&quot;,SpanFromLeft,SpanFromLeft,SpanFromLeft},{&quot;偷吃烧鸡&quot;,&quot;偷吃金鱼&quot;,&quot;偷吃兔子&quot;,&quot;偷吃贡品&quot;}}//Transpose;p={{Item[黑猫.png,Alignment-&gt;Center],SpanFromLeft},{&quot;stuID&quot;,&quot;2186000417&quot;},{&quot;姓名&quot;,&quot;黑猫老弟&quot;},{&quot;精神面貌&quot;,&quot;宠物&quot;},{&quot;主人&quot;,&quot;－－&quot;},{&quot;颜色&quot;,&quot;黑色&quot;},{&quot;业余爱好&quot;,&quot;干坏事&quot;},{Item[Style[&quot;学习成绩&quot;,Bold],Alignment-&gt;Center],SpanFromLeft},{&quot;语文&quot;,&quot;36&quot;},{&quot;数学&quot;,&quot;57&quot;},{&quot;英语&quot;,&quot;49&quot;},{Item[Style[&quot;光荣事迹&quot;,Bold],Alignment-&gt;Center],&quot;偷吃烧鸡&quot;},{SpanFromAbove,&quot;偷吃金鱼&quot;},{SpanFromAbove,&quot;偷吃兔子&quot;},{SpanFromAbove,&quot;偷吃贡品&quot;}};p[[2;;7,1]]=Style[#,Bold]&amp;/@p[[2;;7,1]];p[[9;;11,1]]=Style[#,Bold]&amp;/@p[[9;;11,1]];Grid[p,Alignment-&gt;Left,Frame-&gt;All]","link":"/2022/07/18/%E5%AE%A0%E7%89%A9%E5%90%8D%E7%89%87/"},{"title":"用mathematica改写二部创意曲第八条","text":"Bach的音乐中有着对称美。 平移对称性体现在在不同的时间内交错地再现主题 反演对称性体现在利用倒影（旋转180°）手法创作其他声部 利用mathematica可以更加清楚的揭示声部之间的关系。 举个例子： 二部创意曲第八条 可以看出，上下两个声部几乎是完全一样的，只不过在时间维度上错开了。 利用mathematica可以对这一小段进行在创作 代码如下： 首先，把需要的音符和时值写进去 123456789101112131415161718192021Clear[&quot;`*&quot;]{a, b, c, d} = 0.5*{1, 0.5, 0.25, 0.125};{c4, d4, e4, f4, g4, a4, b4} = {0, 2, 4, 5, 7, 9, 11};{c5, d5, e5, f5, g5, a5, b5} = {c4, d4, e4, f4, g4, a4, b4} + 12;{c6, d6, e6, f6, g6, a6, b6} = {c5, d5, e5, f5, g5, a5, b5} + 12;bb4 = 10;bb5 = 22;time1 = ConstantArray @@@ {{b, 7}, {c, 10}, {b, 6}, {c, 36}, {b, 6}, {c, 12}, {b, 1}, {c, 14}, {b, 1}, {c, 2}, {b, 8}, {a, 1}} // Flatten;note1 = {None, f4, a4, f4, c5, f4, f5, e5, d5, c5, d5, c5, bb4, a4, bb4, a4, g4, f4, a4, c5, a4, f5, c5, a5, c6, bb5, c6, a5, c6, bb5, c6, a5, c6, bb5, c6, f5, a5, g5, a5, f5, a5, g5, a5, f5, a5, g5, a5, d5, f5, e5, f5, d5, f5, e5, f5, d5, f5, e5, f5, b4, g4, d5, b4, f5, d5, g5, a5, g5, f5, e5, f5, e5, d5, c5, d5, c5, bb4, a4, d5, c5, b4, c5, b4, a4, g4, a4, g4, f4, e4, f4, e4, d4, c4, c5, b4, c5, e4, f4, c5, e4, c5, d4, b4, c5}; 然后，原曲（大概的，保持了两个声部的一致性）： 12345Audio@Sound@MapThread[SoundNote[#1, #2, &quot;Piano&quot;] &amp;, {note1, time1}] + Audio@Sound@ MapThread[ SoundNote[#1, #2, &quot;Piano&quot;] &amp;, {Join[ConstantArray[None, 3], note1], Join[{a, a, a}, time1]}] 错开五度123456Audio@Sound@ MapThread[SoundNote[#1, #2, &quot;Piano&quot;] &amp;, {7 + note1, time1}] + Audio@Sound@ MapThread[ SoundNote[#1, #2, &quot;Piano&quot;] &amp;, {Join[ConstantArray[None, 3], note1], Join[{a, a, a}, time1]}] 错开四度123456Audio@Sound@ MapThread[SoundNote[#1, #2, &quot;Piano&quot;] &amp;, {5 + note1, time1}] + Audio@Sound@ MapThread[ SoundNote[#1, #2, &quot;Piano&quot;] &amp;, {Join[ConstantArray[None, 3], note1], Join[{a, a, a}, time1]}] 倒映12345Audio@Sound@MapThread[SoundNote[#1, #2, &quot;Piano&quot;] &amp;, {-note1, time1}] + Audio@Sound@ MapThread[ SoundNote[#1, #2, &quot;Piano&quot;] &amp;, {Join[ ConstantArray[None, 3], -note1], Join[{a, a, a}, time1]}] 这一段是不是有巴赫内味了？(இωஇ ) 两个声部互为倒映：12345Audio@Sound@MapThread[SoundNote[#1, #2, &quot;Piano&quot;] &amp;, {note1, time1}] + Audio@Sound@ MapThread[ SoundNote[#1, #2, &quot;Piano&quot;] &amp;, {Join[ ConstantArray[None, 3], -note1], Join[{a, a, a}, time1]}] 这个听起来不是很舒服。 除此之外，还可以用不同乐器演奏不同的声部，突出声部的独立性。 123456Audio@Sound@ MapThread[SoundNote[#1, #2, &quot;Violin&quot;] &amp;, {12 - note1, time1}] + Audio@Sound@ MapThread[ SoundNote[#1, #2, &quot;Bassoon&quot;] &amp;, {Join[ConstantArray[None, 3], 7 - note1], Join[{a, a, a}, time1]}] 用小提琴演奏高音声部，巴松演奏低音声部。 应该还有好多好玩的。 我创作了一段，第一段用原旋律＋平移对称性，第二段用倒映手法： 12345678910Audio@Sound@ MapThread[ SoundNote[#1, #2, &quot;Violin&quot;] &amp;, {7 + note1~Join~(7 - note1), time1~Join~time1}] + Audio@Sound@ MapThread[ SoundNote[#1, #2, &quot;Piano&quot;] &amp;, {Join[ConstantArray[None, 3], note1]~Join~ Join[ConstantArray[None, 3], 12 - note1], Join[{a, a, a}, time1]~Join~Join[{a, a, a}, time1]}] 是不是感觉和这首管风琴奏鸣曲的手法很像？ bwv525, 也是旋律＋倒映分为两段进行拼接的。 看第三乐章： 第一段：第二段：","link":"/2022/07/18/%E7%94%A8mathematica%E6%94%B9%E5%86%99%E4%BA%8C%E9%83%A8%E5%88%9B%E6%84%8F%E6%9B%B2%E7%AC%AC%E5%85%AB%E6%9D%A1/"}],"tags":[{"name":"诗","slug":"诗","link":"/tags/%E8%AF%97/"},{"name":"日记","slug":"日记","link":"/tags/%E6%97%A5%E8%AE%B0/"},{"name":"mathematica","slug":"mathematica","link":"/tags/mathematica/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"物理","slug":"物理","link":"/tags/%E7%89%A9%E7%90%86/"},{"name":"音乐","slug":"音乐","link":"/tags/%E9%9F%B3%E4%B9%90/"},{"name":"日常","slug":"日常","link":"/tags/%E6%97%A5%E5%B8%B8/"}],"categories":[{"name":"日常","slug":"日常","link":"/categories/%E6%97%A5%E5%B8%B8/"}]}